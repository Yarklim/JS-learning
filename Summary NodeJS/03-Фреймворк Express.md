Введение в Express
Express - это минималистичный и гибкий веб-фреймворк для приложений Node.js, предоставляющий обширный набор функций для мобильных и веб-приложений. Он имеет в своем распоряжении множество служебных методов HTTP и промежуточных обработчиков, чтобы создать надежный API или веб-сайт.

Давайте сразу приступим к практике. Создайте каталог для своего приложения и сделайте его своим рабочим каталогом.

$ mkdir myapp
$ cd myapp

С помощью команды

$ npm init -y

создайте файл package.json для своего приложения. Теперь установите Express в каталоге myapp и сохраните его в списке зависимостей. Например:

$ npm install express

В каталоге myapp создайте файл с именем app.js и добавьте следующий код:

const express = require('express');
const app = express();

app.get('/', (req, res) => {
  res.send('Hello World!');
});

app.listen(3000, () => {
  console.log('Example app listening on port 3000!');
});

Приложение запускает сервер и слушает соединения на порте 3000 командой.

$ node app.js

Приложение выдает ответ “Hello World!” в браузере на запросы, адресованные корневому URL (/) или маршруту. Для всех остальных путей ответом будет статус 404 - Not Found. Для обработки запросов, маршрутов, в Express определено ряд встроенных функций. Маршрутизация определяет, как ваше приложение отвечает на клиентский запрос к конкретному адресу - URL. Каждый маршрут может иметь одну или больше функций обработки, которые выполняются при сопоставлении маршрута. Определение маршрута, согласно документации, имеет следующую структуру:

app.METHOD(PATH, HANDLER)

Где:
app — это экземпляр express приложения.
METHOD -— метод запроса HTTP (GET, POST, PUT, PATCH, DELETE).
PATH —- путь на сервере, в нашем случае это корень сайта '/'.
HANDLER —- функция, выполняемая при сопоставлении маршрута.

Давайте кратко определим для чего используются каждый из HTTP глаголов:

GET запрашивает представление ресурса. Запросы с использованием этого метода могут только извлекать данные.

POST используется для отправки сущностей к определенному ресурсу. Часто вызывает изменение состояния или какие-то побочные эффекты на сервере.

PUT заменяет все текущие представления ресурса данными запроса.

DELETE удаляет указанный ресурс.

PATCH используется для частичного изменения ресурса.

Мы еще вернемся к глаголам когда будем рассматривать создание REST API

В нашем случае функция HANDLER принимает два параметра, объект запроса req и объект ответа res.

(req, res) => {
  res.send('Hello World!');
};

Для запуска сервера вызывается метод app.listen(), в который передается номер порта. Приложение выдает ответ "Hello World!" на запросы, адресованные корневому URL (/) или маршруту. Для всех остальных путей, например, http://localhost:3000/contact, ответом будет

Cannot GET /contact

Стоит отметить, что req (запрос) и res (ответ) являются аналогичными объектами, с которыми мы работали, когда рассматривали простой веб-сервер на Node.js.

Добавим обработчик маршрута contact

app.get('/contact', (req, res) => {
  res.send('<h1>Contact page</h1>');
});

И теперь по пути http://localhost:3000/contactсервер нам будет возвращать страничку с заголовком Contact page.

NOTE
Не забывайте перезапустить сервер, чтобы увидеть изменения в коде.

Как уже говорилось, когда приходит запрос, Express сопоставляет запрошенный адрес с каждым из маршрутов. При совпадении маршрута вызывается его функция обработчик. Но определения маршрутов, кроме простых строк, могут также содержать регулярные выражения или специальные символы подстановок. В частности, мы можем использовать такие символы, как ?, +, * и ().

Символ ? в маршруте указывает, что предыдущий символ может встречаться 1 раз или отсутствовать. Приведенный ниже путь маршрута сопоставляет cotact и contact.

app.get('/con?tact', (req, res) => {
  res.send('<h1>Contact page</h1>');
});

Символ + указывает, что предыдущий символ может встречаться 1 и более раз. Этот путь маршрута сопоставляет contact, conntact, connntact и т.д.

app.get('/con+tact', (req, res) => {
  res.send('<h1>Contact page</h1>');
});

Символ звездочка * указывает, что на месте этого символа может находиться любое количество символов. Этот путь маршрута сопоставляет contact, conxtact, con123tact и т.д.

app.get('/con*tact', (req, res) => {
  res.send('<h1>Contact page</h1>');
});

Стоит отметить, что хотя такая возможность и есть, но лучше для маршрутов выбирать простые строки без символов.

Промежуточное ПО
Мы плавно подошли к теме промежуточного ПО. На деле промежуточное ПО — просто функция, принимающая три аргумента: объект запроса (req), объект ответа (res) и функцию next. Промежуточное ПО выполняется способом, называемым конвейерной обработкой. Представьте себе водопроводную трубу, по которой течет вода. Вода закачивается через один конец трубы и проходит через манометры и клапаны, наше промежуточное ПО, прежде чем попадает по назначению - в наш стакан. Важный момент этой аналогии в том, что очередность имеет ключевое значение.

Встроим собственное промежуточное ПО в наш файл app.js перед вызовом статики.

app.use((req, res, next) => {
  console.log('Наше промежуточное ПО');
  next();
});

Это функция ничего не выполняет, просто пропускает поток через себя, но в консоль всегда будет выскакивать наше сообщение.


Рис. 5 - срабатывание промежуточного ПО
ОПРЕДЕЛЕНИЕ
Функции промежуточной обработки (middleware) - это функции, имеющие доступ к объекту запроса (req), объекту ответа (res) и к следующей функции промежуточной обработки в цикле "запрос-ответ" приложения. Следующая функция промежуточной обработки, как правило, обозначается переменной next.

Функции промежуточной обработки выполняют следующие задачи:

выполняют некоторый код.
вносят изменения в объекты запросов и ответов.
могут завершить цикл "запрос-ответ" и прервать обработку запроса.
вызывают следующую функцию промежуточной обработки из стека, выполнением функции next().
ВАЖНО!
Если текущая функция промежуточной обработки не завершает цикл "запрос-ответ", она должна вызвать next() для передачи управления следующей функции промежуточной обработки. В противном случае запрос зависнет.

Передача данных на сервер
Передача параметра в URL
Первый способ - передать через параметр. Маршруты могут содержать параметры — именованные сегменты URL-адреса. Название параметра должно включать символы из диапазона [A-Za-z0-9_]. В определении маршрута, перед параметром, ставится знак двоеточия. Добавим следующий обработчик для маршрута:

app.get('/contact/:id', (req, res) => {
  res.send(`<h1>Contact</h1> Параметр: ${req.params.id}`);
});

Само собой если мы теперь обратимся по маршруту /contact/123 то req.params.id будет содержать значение 123. Этот способ передачи параметров на сервер используют очень часто. Например редактирование пользователя может выглядеть следующим образом

app.patch('/user/:userid', (req, res) => {
  const id = req.params.userid;
  // выполняем необходимые действия
});

Мы увидим это, когда будем рассматривать REST API

Использование параметров GET запроса
Второй способ - это разбор строки GET запроса. После URL - адреса, по которому происходит обращение на сервер, ставится вопросительный знак ?, за которым следует список аргументов, разделенных символами &. Что-то ввиде

http://localhost:3000/contacts?skip=0&limit=10

Без этого способа не обходится не одна реализация пагинации на странице. Результат такого запроса находится в объекте req.query. В нашем конкретном случае

{
  skip: 0,
  limit: 10
}

Если в GET запросе HTTP параметры строки запроса не заданы например /search, а знака вопроса и после него ничего нет, то req.query по умолчанию содержит пустой объект: {}

Фреймворк Express, содержит встроенное средство разбора строк запросов, потому что эта задача очень часто встречается в веб-разработке.

Отправка с помощью форм
При отправке каких-то данных на сервер обычно используются HTTP методы POST, PUT и PATCH. Это стандартный способ при отправке формы. Рассмотрим, как получать такие данные в Express.

Формат HTTP сообщения состоит из списка заголовков и тела сообщения. Запрос POST от формы стандартно имеет заголовок Content-Type: application/x-www-form-urlencoded. Прежде всего для получения отправленных данных необходимо подключить парсер через промежуточное ПО и он уже содержится в фреймворке. Для создания парсера данных от форм применяется функция urlencoded().:

app.use(express.urlencoded({ extended: false }));

В эту функцию передается объект, устанавливающий параметры парсинга. Значение extended: false указывает, что результат парсинга будет представлять собой набор пар ключ-значение, а каждое значение может быть представлено в виде строки или массива. Когда этот параметр равен true, парсер использует другую библиотеку для разбора формата строки.

Пусть, мы принимаем информацию от формы аутентификации.

<form action="/login" method="POST">
  <label for="email">Email</label>
  <input type="text" name="email" id="email" />
  <label for="password">Пароль</label>
  <input type="password" name="password" id="password" />
  <button type="submit">Войти</button>
</form>

Браузер отправит на URL <урл нашего приложения>/login данные формы. Это будут две переменные: email и password. За это отвечают атрибуты name у соответствующих тегов input. Эти данные мы должны принять на стороне сервера следующим обработчиком

app.post('/login', (req, res, next) => {
  const { email, password } = req.body;
  // Выполняем необходимые операции
});

В результате сервер должен получить данные в объекте req.body, следующего вида:

{
  email: 'Значение что было введено в поле input',
  password: 'Значение что было введено в поле input'
}

Передача JSON
При создании веб-приложений на Node.js, часто приходится работать с данными в JSON формате. Это основная форма передачи данных для Web-API, еще есть формат XML, но он все больше устаревает из-за своей многословности при формировании данных и выходит из обращения. Парсер JSON в приложении подключается следующим образом.

app.use(express.json());

Передать данные в виде JSON, можно клиентским JavaScript, утилитой curl для linux систем или с помощью специальной утилиты по типу Postman. В основном мы будем пользоваться утилитой Postman, с которой плотно познакомимся, когда будем разбирать создание REST API

После того как парсер JSON будет подключен, наши обработчики запросов могут интерпретировать значение req.body как объект JavaScript вместо строки.

app.post('/login', (req, res, next) => {
  const { email, password } = req.body;
  // Выполняем необходимые операции
});

Данный пример предполагает, что был отправлен объект JSON со свойствами email и password. И главное у запроса заголовок Content-Type должен содержать application/json, а вы должны отправить действительную раз­метку JSON.

Мы рассмотрели все базовые виды отправки данных на сервер, которые нам понадобятся в дальнейшем.

Роутинг в приложении
Методы Route
С помощью класса express.Router можно создавать модульные, монтируемые обработчики маршрутов. Экземпляр Router представляет собой комплексную систему промежуточных обработчиков и маршрутизации; по этой причине его часто называют «мини-приложением».

const express = require('express');
const router = express.Router();

// определим домашний роутер
router.get('/', (req, res) => {
  res.send('Это главный роутер');
});

// определим роутер about
router.get('/about', (req, res) => {
  res.send('About');
});

module.exports = router;

Потом подключим модуль my-router.js маршрутизации в приложение:

const myRouter= require('./my-router');
...
app.use('/my-router', myRouter);

Данное приложение теперь сможет обрабатывать запросы, адресованные ресурсам /my-router и /my-router/about.

Express поддерживает большое количество методов маршрутизации, соответствующие методам HTTP, но с большинством мы даже не будем иметь дело, основные методы для нас будут:

get
post
put
delete
patch
Существует также особый метод маршрутизации, app.all(), не являющийся производным от какого-либо метода HTTP. Этот метод используется для загрузки функций промежуточной обработки в пути для всех методов запросов. Он бывает полезен когда нам надо реагировать на любое обращение к серверу.

В приведенном ниже примере обработчик будет запущен для запросов, адресованных /anything, независимо от того, используется ли GET, POST, PUT, DELETE или какой-либо другой метод запроса HTTP, поддерживаемый в модуле http.

app.all('/anything', (req, res, next) => {
  console.log('Anything method.');
  next(); // передаем управление дальше
});

Методы ответа
Методы в объекте ответа (res), перечисленные в таблице ниже, могут передавать ответ клиенту и завершать цикл “запрос-ответ”. Если ни один из этих методов не будет вызван из обработчика маршрута, клиентский запрос зависнет.

Метод	Описание
res.download()	Приглашение загрузки файла
res.end()	Завершение процесса ответа
res.json()	Отправка ответа JSON
res.jsonp()	Отправка ответа JSON с поддержкой JSONP
res.redirect()	Перенаправление ответа
res.render()	Вывод шаблона представления
res.send()	Отправка ответа различных типов
res.sendFile()	Отправка файла в виде потока октетов
Цепочки методов
Метод app.route() позволяет создавать обработчики маршрутов, образующие цепочки, для конкретного пути маршрута. Поскольку путь один и тот же для разных методов HTTP, удобно создавать модульные маршруты, чтобы минимизировать избыточность и количество опечаток. Ниже приведен пример объединенных в цепочку обработчиков маршрутов, определенных с помощью функции app.route().

app
  .route('/blog')
  .get((req, res) => {
    res.send('Get a list of blog');
  })
  .post((req, res) => {
    res.send('Add a record to blog');
  })
  .put((req, res) => {
    res.send('Update blog');
  });