Основы MongoDB
Современному веб-приложению необходимо хранилище данных. Традиционно для этого использовались SQL базы данных, но прогресс не стоит на месте и появилась альтернатива в виде NoSQL баз данных. Эти базы данных приняли во внимание распределенную природу сети Интернет и, подобно Node.js, вместо этого сосредоточились на параллелизме для масштабирования производительности. Мы рассмотрим ведущую документоориентированную базу данных MongoDB.

MongoDB является нереляционной базой данных типа NoSQL. База основана на модели документов - объекты данных хранятся в виде отдельных документов в коллекции

Коллекция и документ
Данные в MongoDB группируются в коллекции. Коллекция - это собрание документов, имеющих одинаковое назначение. Коллекция подобная таблице в SQL базе данных, но отличается тем, что для коллекции нет строгой схемы и документы коллекции могут иметь разную структуру.

Документ - это представление элемента информации в базе данных. Они могут состоять из подчиненных документов, и эта модель данных больше подходит для веб-приложений. Максимальный размер документа ограничен 16 Мбайт.

В MongoDB в качестве языка запросов используется JavaScript и JSON-структуры. Выбор языка запроса объясняется тем, что MongoDB использует JSON-формат для представления документов и вывода результатов. Физически JSON-структуры хранятся в бинарном BSON-формате.

BSON

Документы (т.е. объекты) соответствуют собственным типам данных во многих языках программирования. Встроенные документы и массивы сокращают потребность в дорогостоящих объединениях.

В следующей таблице представлены различия в терминологии между SQL и MongoDB.

SQL термины	MongoDB термины
база данных	база данных
таблица	коллекция
строка	документ
столбец	поле
индекс	индекс
joins	$lookup
Первичный ключ. В SQL надо указать любой уникальный столбец или комбинацию столбцов в качестве первичного ключа. В MongoDB первичный ключ автоматически устанавливается в поле _id. Фактически переменная _id это объект типа ObjectId

_id: ObjectId('5f15996fbbde793a107af359');

Он содержит 12 байт, каждый из которых формируется определенным образом.

4 - байтовое значение (5f15996f), обозначающее секунды, начиная с последней записи
3 - байтовое значение (bbde79), обозначающее идентификатор машины
2 - байтовое значение (3a10), обозначающее идентификатор процесса
3 - байтовый счетчик (7af359), начиная со случайного значения
MongoDB Atlas
Вместо установки базы данных локально, мы будем использовать облачное хранилище MongoDB Atlas.

MongoDB Atlas - это вариант службы MongoDB, размещенной в облаке, который не требует дополнительных затрат на установку и предлагает бесплатный уровень для начала работы.

Пройдите регистрацию, лучше всего привязав к облаку свою учетную запись Google. Создайте свой первый кластер. Выбирайте регион с бесплатным кластером M0 Sandbox, размером в 512 Мб. Если все прошло успешно, у вас должен быть доступ к dashboard

dashboard

Теперь необходимо выполнить предварительную настройку нашей облачной базы. Первое, перейдите в левом меню на вкладку Network Access и добавьте IP адреса у которых будет доступ к облачной базе данных.

ip

Как вариант можно разрешить доступ с любого IP адреса 0.0.0.0/0. Но можете указать только необходимые вам адреса.

Вторым шагом необходимо завести пользователя для нашей базы данных. Эту учетную запись мы будем использовать для доступа к базе данных из нашего приложения и графического интерфейса. Переходим во вкладку Database Access и выбираем Add New Database User. Выбираем метод аутентификации с помощью пароля. Придумайте имя и пароль пользователю и запомните, мы поместим их в дальнейшем в переменные окружения. Также выставьте привилегии доступа как чтение и запись в базу данных.

Database Access

Предварительная настройка закончена и теперь можно вернуться на вкладку Cluster. Здесь выбираем Connect. В открывшемся окне выбираем Connect your application

Cluster

Надо выбрать драйвер для Node.js. Нам предоставят строку для доступа к базе данных

mongodb+srv://<username>:<password>@krabaton.5mlpr.gcp.mongodb.net/<dbname>?retryWrites=true&w=majority

В этой строке есть три плейсхолдера:

<username> - имя пользователя что мы зарегистрировали
<password> - его пароль
<dbname> - имя базы данных. Будет создана при обращении к облаку.
С помощью этой строки мы будем соединяться с нашей облачной базой данных

MongoDB GUI
Существует множество графических инструментов управления MongoDB. Эти инструменты повышают производительность наших задач разработки и администрирования MongoDB. Они удобны и чаще всего предоставляют внутреннюю консоль для работы с БД или ее аналог. Рассмотрим два популярных графических инструмента MongoDB и разберемся как в них подключиться к облачной базе данных. Этих двух инструментов вполне хватит для всех нужд при прохождении курса.

MongoDB Compass
Графический интерфейс для MongoDB от самой компании. Обладает неплохой визуализацией данных и имеет полную функциональностью CRUD. Доступен для платформ на Linux, Mac или Windows.

Подключение к базе данных производится с помощью строки SRV

connect

Необходимо вставить строку с уже подставленными плейсхолдерами в блок подключения Compass и нажать кнопку connect

connect

Слева будет меню с нашими базами и коллекциями. При выборе коллекции мы попадаем в панель управления коллекцией. Вместо консоли Compass предоставляет панель для поиска и фильтрации по нашим документам. И полную функциональность по CRUD операциям над документами, без необходимости использования языка запросов. Compass достаточно простой и очень хорошо подходит для новичка.

Robo 3T
Популярный бесплатный графический интерфейс для энтузиастов MongoDB. Этот легкий инструмент с открытым исходным кодом имеет кроссплатформенную поддержку, а также встраивает оболочку mongo в свой интерфейс для обеспечения взаимодействия как на основе оболочки, так и на основе графического интерфейса. Он разработан 3T Software, командой, стоящей за Studio 3T, IDE для MongoDB, которая полностью платная в отличие от этой версии.

connect

При старте появится окно предлагающее подключится к базе данных. Здесь есть небольшой нюанс. Нажмите Create

connect

Мы увидим окно предлагающее нам ввести credentials для присоединения. Не спешите вводить имя пользователя, его пароль и остальную информацию. Robo 3T умеет это делать сам из строки подключения которую нам предоставляет MongoDB Atlas. Вставьте строку в самое нижнее поле ввода и нажмите From SRV и Robo 3T сам подставит везде нужную информацию. Дайте своему подключению имя, нажмите save, а после выполните connect к облачной базе данных

connect

Интерфейс похож на предыдущую программу, но вместо панели вверху мы видим консоль с запросами к базе данных. Например вывод коллекции был выполнен командой

db.getCollection('cats').find({});

Выполнение команд выполняется клавишей F5 или комбинацией клавиш Ctrl+Enter. В этом учебнике мы будем использовать этот GUI и уже в следующем разделе в полной мере им воспользуемся.

Основные команды MonogDB
После подключения к облачной базе MongoDB, кликните правой кнопкой мыши на любой базе в левой панели Robo 3T. В контекстном меню выберите Open shell - откроется консоль в который мы будем работать.

Первая команда будет

use test

Выполняется она нажатием клавиши F5 или комбинацией клавиш Ctrl+Enter. Теперь в качестве текущей будет установлена БД test.

test

Если мы хотим узнать, какая бд используется в текущей момент, то мы можем воспользоваться командой db:

 db

Используя команду db.stats(), можно получить статистику по текущей базе данных, а статистику по коллекции cats:

db.cats.stats();

Но прежде чем получить статистику по коллекции ее надо создать.

Добавление в коллекцию
Можно использовать для этого три метода:

insertOne: добавляет один документ
insertMany: добавляет несколько документов
insert: может добавлять как один, так и несколько документов
Кликнем правой кнопкой мыши по базе test, в контекстном меню вызовем консоль и вставим информацию по первому коту:

db.cats.insertOne({
  name: 'barsik',
  age: 3,
  features: ['ходит в тапки', 'дает себя гладить', 'рыжий'],
});

Нам вернется результат:

{
  "acknowledged": true,
  "insertedId": ObjectId("5f837f855ba83a4f1829ca5b")
}

Он означает, что результат был добавлен в коллекцию cats. Двойным кликом по имени cats коллекции в левом меню мы откроем новую вкладку с консолью, где автоматически выполнится команда

db.getCollection('cats').find({});

insert

Есть некоторые ограничения при использовании имен ключей:

Символ $ не может быть первым символом в имени ключа
Имя ключа не может содержать символ точки .
Имя _id не рекомендуется использовать
Используем вставку данных сразу по двум кошкам

db.cats.insertMany([
  {
    name: 'Lama',
    age: 2,
    features: ['ходит в лоток', 'не дает себя гладить', 'серый'],
  },
  {
    name: 'Liza',
    age: 4,
    features: ['ходит в лоток', 'дает себя гладить', 'белый'],
  },
]);

Результат ответа будет похожим на этот - нам вернули два уникальных идентификатора вновь созданных документов

{
  "acknowledged": true,
  "insertedIds": [
    ObjectId("5f8382425ba83a4f1829ca5c"),
    ObjectId("5f8382425ba83a4f1829ca5d")
  ]
}

И последний вариант это универсальная вставка командой insert

db.cats.insert([
  {
    name: 'Boris',
    age: 12,
    features: ['ходит в лоток', 'не дает себя гладить', 'серый'],
  },
  {
    name: 'Murzik',
    age: 1,
    features: ['ходит в лоток', 'дает себя гладить', 'черный'],
  },
]);

После этой ставки в нашей коллекции должно находится пять документов

five

Поиск в коллекции
Для вывода документов в используется метод find:

db.cats.find();

Результат в консоли должен быть на этот момент следующим

{
    "_id" : ObjectId("5f837f855ba83a4f1829ca5b"),
    "name" : "barsik",
    "age" : 3.0,
    "features" : [
        "ходит в тапки",
        "дает себя гладить",
        "рыжий"
    ]
}

{
    "_id" : ObjectId("5f8382425ba83a4f1829ca5c"),
    "name" : "Lama",
    "age" : 2.0,
    "features" : [
        "ходит в лоток",
        "не дает себя гладить",
        "серый"
    ]
}

{
    "_id" : ObjectId("5f8382425ba83a4f1829ca5d"),
    "name" : "Liza",
    "age" : 4.0,
    "features" : [
        "ходит в лоток",
        "дает себя гладить",
        "белый"
    ]
}

{
    "_id" : ObjectId("5f8383025ba83a4f1829ca5e"),
    "name" : "Boris",
    "age" : 12.0,
    "features" : [
        "ходит в лоток",
        "не дает себя гладить",
        "серый"
    ]
}

{
    "_id" : ObjectId("5f8383025ba83a4f1829ca5f"),
    "name" : "Murzik",
    "age" : 1.0,
    "features" : [
        "ходит в лоток",
        "дает себя гладить",
        "черный"
    ]
}

В MongoDB в запросах можно использовать условные конструкции с помощью операторов сравнения:

$eq (равно)
$gt (больше чем)
$lt (меньше чем)
$gte (больше или равно)
$lte (меньше или равно)
db.cats.find({ age: { $lte: 3 }, features: 'дает себя гладить' });

Результат:

{
  "_id" : ObjectId("5f837f855ba83a4f1829ca5b"),
  "name" : "barsik",
  "age" : 3.0,
  "features" : [
    "ходит в тапки",
    "дает себя гладить",
    "рыжий"
  ]
}

{
  "_id" : ObjectId("5f8383025ba83a4f1829ca5f"),
  "name" : "Murzik",
  "age" : 1.0,
  "features" : [
    "ходит в лоток",
    "дает себя гладить",
    "черный"
  ]
}

Проекция
Иногда нам нужна не вся информация из документа, а например определенные поля или наоборот некоторые поля надо исключить

db.cats.find({ age: { $lte: 3 }, features: 'дает себя гладить' }, { name: 0 });

Результат, вторым объектом в функции find мы исключили вывод поля name

{
  "_id" : ObjectId("5f837f855ba83a4f1829ca5b"),
  "age" : 3.0,
  "features" : [
    "ходит в тапки",
    "дает себя гладить",
    "рыжий"
  ]
}

{
  "_id" : ObjectId("5f8383025ba83a4f1829ca5f"),
  "age" : 1.0,
  "features" : [
    "ходит в лоток",
    "дает себя гладить",
    "черный"
  ]
}

А можем наоборот, оставить вывод только двух необходимых полей

db.cats.find(
  { age: { $lte: 3 }, features: 'дает себя гладить' },
  { name: 1, age: 1 },
);

Результат

{
  "_id" : ObjectId("5f837f855ba83a4f1829ca5b"),
  "name" : "barsik",
  "age" : 3.0
}

{
  "_id" : ObjectId("5f8383025ba83a4f1829ca5f"),
  "name" : "Murzik",
  "age" : 1.0
}

Стоит заметить, что поле _id выводится всегда, если только принудительно не запретить его вывод _id: 0

Запрос к вложенным объектам
Давайте вставим новый документ с полем объектом owners

db.cats.insert({
  name: 'Dariy',
  age: 10,
  features: ['ходит в лоток', 'не дает себя гладить', 'серый'],
  owners: { name: 'Nata', age: 23, address: 'Poltava' },
});

Чтобы выполнить поиск по вложенному объекту, надо использовать точку owners.name

db.cats.find({ 'owners.name': 'Nata' });

Результат:

{
  "_id": ObjectId("5f838b225ba83a4f1829ca60"),
  "name": "Dariy",
  "age": 10.0,
  "features": ["ходит в лоток", "не дает себя гладить", "серый"],
  "owners": {
    "name": "Nata",
    "age": 23.0,
    "address": "Poltava"
  }
}

Дополнительная настройка запросов:
Чтобы ограничить выборку используется функция limit. Например показать первые три документа в коллекции

db.cats.find().limit(3);

Чтобы пропустить некоторое количество документов в выборке используется функция skip. Например пропустить три документа в выборке

db.cats.find().skip(3);

Сортировка в выборке выполняется функцией sort, которая принимает объект с полями для сортировки и они принимают значения: 1 по возрастанию, -1 по убыванию

db.cats.find().sort({ name: 1 });

С помощью функции count() можно получить число элементов в коллекции:

db.cats.count();

Результат: 6

Оператор $exists позволяет извлечь только те документы, в которых определенный ключ присутствует или отсутствует.

db.cats.find({ owners: { $exists: true } });

Оператор $type извлекает только те документы, в которых определенный ключ имеет значение определенного типа, например, строку или число

db.cats.find({ age: { $type: 'number' } });

Оператор $regex задает регулярное выражение, которому должно соответствовать значение поля.

db.cats.find({ name: { $regex: 'L' } });

Результат:

{
  "_id" : ObjectId("5f8382425ba83a4f1829ca5c"),
  "name" : "Lama",
  "age" : 2.0,
  "features" : [
    "ходит в лоток",
    "не дает себя гладить",
    "серый"
  ]
}

{
  "_id" : ObjectId("5f8382425ba83a4f1829ca5d"),
  "name" : "Liza",
  "age" : 4.0,
  "features" : [
    "ходит в лоток",
    "дает себя гладить",
    "белый"
  ]
}

Оператор логического умножения $or, позволяет объединить выборки

db.cats.find({ $or: [{ name: { $regex: 'L' } }, { age: { $lte: 3 } }] });

Результат:

{
  "_id" : ObjectId("5f837f855ba83a4f1829ca5b"),
  "name" : "barsik",
  "age" : 3.0,
  "features" : [
    "ходит в тапки",
    "дает себя гладить",
    "рыжий"
  ]
}

{
  "_id" : ObjectId("5f8382425ba83a4f1829ca5c"),
  "name" : "Lama",
  "age" : 2.0,
  "features" : [
    "ходит в лоток",
    "не дает себя гладить",
    "серый"
  ]
}

{
  "_id" : ObjectId("5f8382425ba83a4f1829ca5d"),
  "name" : "Liza",
  "age" : 4.0,
  "features" : [
    "ходит в лоток",
    "дает себя гладить",
    "белый"
  ]
}

{
  "_id" : ObjectId("5f8383025ba83a4f1829ca5f"),
  "name" : "Murzik",
  "age" : 1.0,
  "features" : [
    "ходит в лоток",
    "дает себя гладить",
    "черный"
  ]
}

Оператор логического умножения $and, находит пересечения выборок

db.cats.find({ $and: [{ name: { $regex: 'L' } }, { age: { $lte: 3 } }] });

Результат:

{
  "_id": ObjectId("5f8382425ba83a4f1829ca5c"),
  "name": "Lama",
  "age": 2.0,
  "features": ["ходит в лоток", "не дает себя гладить", "серый"]
}

Курсоры
Результат выборки, получаемой с помощью функции find, называется курсором. Курсоры инкапсулируют в себе наборы получаемых из БД объектов. Используя синтаксис языка JavaScript и методы курсоров, мы можем вывести полученные документы на экран и как-то их обработать.

const cursor = db.cats.find();
while (cursor.hasNext()) {
  obj = cursor.next();
  print(obj['name']);
}

Результат:

barsik
Lama
Liza
Boris
Murzik
Dariy

Сохранение документов
Сохранение документов можно выполнить методов save. В новый документ в качестве поля можно передать параметр _id. Если метод находит документ с таким значением _id, то документ обновляется. Если же с подобным _id нет документов, то документ вставляется.

db.cats.save({ name: 'Bars', age: 3 });

Обновление документов
Более детальную настройку при обновлении предлагает функция update. Она принимает три параметра:

query: принимает запрос на выборку документа, который надо обновить
objNew: представляет документ с новой информацией, который заместит старый при обновлении
options: определяет дополнительные параметры при обновлении документов. Может принимать два аргумента: upsert и multi.
Если параметр upsert имеет значение true, что MongoDB будет обновлять документ, если он найден, и создавать новый, если такого документа нет. Если же он имеет значение false, то MongoDB не будет создавать новый документ, если запрос на выборку не найдет ни одного документа.

Параметр multi указывает, должен ли обновляться первый элемент в выборке (используется по умолчанию, если данный параметр не указан) или же должны обновляться все документы в выборке.

db.cats.update({ name: 'Bars' }, { name: 'Tom', age: 5 }, { upsert: true });

оператор $set - если документ не содержит обновляемое поле, то оно создается

db.cats.update(
  { name: 'Tom' },
  { $set: { features: ['ходит в лоток', 'не дает себя гладить', 'серый'] } },
);

Указав значение multi:true, мы можем обновить все документы выборки {multi:true}

Для удаления отдельного ключа используется оператор $unset:

db.cats.update({ name: 'Tom' }, { $unset: { age: 1 } });

Метод updateOne похож на метод update за тем исключением, что он обновляет только один документ. Если необходимо обновить все документы, соответствующие некоторому критерию, то применяется метод updateMany

Удаление документа
Для удаления документов в MongoDB предусмотрен метод remove:

Удаление всех документов с указанным запросом

db.cats.remove({ name: 'Tom' });

Если необходимо удалить, только один документ

db.cats.remove({ name: 'Tom' }, true);