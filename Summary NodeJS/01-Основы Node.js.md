Введение
Платформа Node.js - это среда выполнения JavaScript на стороне сервера. Это значит, что разработчики могут использовать один и тот же язык программирования как для front-end, так и для back-end части веб-приложений, над которыми они работают. Новая версия Node.js появляется как минимум дважды за год.

Согласно опросу Stack Overflow 2019, Node.js является самым популярным инструментом в категории «Фреймворки, библиотеки и инструменты» и имеет 50% выбора среди профессиональных разработчиков.

Области применения технологии
Что же делает Node.js таким привлекательным для разработчиков? Давайте рассмотрим области применения технологии по порядку

Разработка API
Это наверное самый популярный вид приложений на сегодняшний момент. Почти все веб-приложения нуждаются в каком-либо сервере для связи с базами данных или другими внешними службами. Благодаря большому сообществу вы можете легко найти библиотеку для создания, например, REST или GraphQL API.

Создание стриминговых приложения
Node.js - хороший выбор для потоковой передачи данных. Можно создавать потоковые сервисы для прослушивания музыки или просмотра видео. Он имеет встроенный модуль потоков, позволяющий последовательно передавать огромное количество данных частями. Благодаря этому вам вообще не нужно временно хранить или кэшировать данные в памяти приложения.

Приложения реального времени
Можно создавать приложения по типу чатов или видеоконференций, где люди могут разговаривать друг с другом в реальном времени. Например такие приложения как Slack или Discord написаны на Node.js. Или инструменты для совместной работы над одним и тем же документом одновременно для нескольких человек.

Microservices
Микросервисы в последнее время стали популярным подходом в разработке приложений. Благодаря легковесности и простоте Node.js это предпочтительная и легко масштабируемая технология для создания и развертывания микросервисов.

Консольные приложения
Благодаря огромному количеству доступных пакетов в NPM репозитории можно легко создавать инструменты командной строки любой сложности.

Настольные приложения
Благодаря фреймворку Electron мы можем строить настольные приложения на базе веб-технологий. Это текстовые редакторы Atom и Visual Studio Code, а так же уже упоминавшийся чат-сервис Slack.

Основные преимущества
Пришло время поговорить о преимуществах технологии, а они несомненно существуют раз технология так широко используется.

Репозиторий NPM с открытым исходным кодом
Здесь находится множество доступных модулей и вы можете легко найти готовое решение для вашего приложения, вместо того, чтобы изобретать велосипед.

Масштабируемые системы
С Node.js легко масштабировать приложение по горизонтали, разворачивая множество экземпляров вашего проекта на разных серверах. Также доступно вертикальное масштабирование, используя встроенный модуль cluster, который будет разветвлять процесс приложения на все имеющиеся у вас ядра CPU.

Подходит для микросервисов
Многие компании выбирают Node.js, когда хотят перейти на микросервисы. Он идеально зарекомендовал себя для этого архитектурного решения.

Единый язык программирования
В настоящее время основным языком для front-end является JavaScript. Использование его на стороне back-end, позволяет вам использовать full-stack разработчика, а не нанимать двух человек для разных позиций. Экономия времени и денег для бизнеса всегда было и будет большим преимуществом.

Парадигма асинхронного ввода-вывода
Основная проблема с операциями ввода-вывода - это ожидание ответа. Использование неблокирующего API позволяет продолжить работу над другой задачей, не дожидаясь ответа предыдущей. И только когда операция ввода-вывода будет завершена, вы получите уведомление об этом с помощью обратного вызова или промиса. Главное преимущество этого подхода - повышение эффективности за счет обработки большого количества одновременных подключений.

Повторно используемый код
Поскольку основным языком является JavaScript, вы можете легко обмениваться частями кода между различными компонентами вашей системы. Более того, вы можете использовать одни и те же части кода как во front-end, так и в back-end части приложения.

Время выхода на рынок
Очень часто у бизнеса есть отличная идея которую надо проверить на рынке. С помощью Node.js вы можете очень быстро предоставить MVP (Минимально жизнеспособный продукт, minimum viable product, MVP — продукт, обладающий минимальными, но достаточными для удовлетворения первых потребителей функциями), что уменьшит количество денег и усилий, необходимых для его реализации.

Протестировано на производстве
С момента создания Node.js в 2009 году у многих компаний была возможность проверить, как Node.js работает на производстве. И технология показала себя хорошо, поэтому многие крупные компании решили перейти на Node.js.

Какие компании используют Node.js в своих приложениях?
Список компаний, использующих Node.js в производстве достаточно обширен: Netflix, Microsoft, Uber и другие. Capital One, огромная финансовая корпорация, выполняет множество проектов из-за коротких циклов разработки на Node.js. Рекламные агентства, такие как Fusion Marketing, Walmart в розничной торговле, Uber в транспорте, Google, Twitter, GoDaddy и список можно продолжать и продолжать.

Если вам интересен опыт применения Node.js от других компаний, то существует серия бесед по Node Enterprise, где каждый эпизод посвящен отдельному варианту использования Node.js.

Примечание: Видео на английском языке


Вывод
Если подвести итог всего вышесказанного, то по сути, любой бизнес, использующий Node.js, может: нанять меньше разработчиков, использовать меньше серверов, уменьшить время разработки приложения.

Модульная система Node.js
Глобальные переменные
Чтобы сделать в Node.js переменную глобальной, надо объявить ее как свойство объекта Global.

global.foo = 3;

Фактически объект Global это аналог объекта window из браузера. Метод require, служащий для подключения модулей не является глобальным и будет локальным для каждого модуля.

Так же локальными для каждого модуля являются:

module.export – объект, отвечающий за то, что именно будет экспортировать модуль при использовании require;
__filename – имя файла исполняемого скрипта;
__dirname – абсолютный путь до исполняемого скрипта.
Мы вернемся к ним чуть позже и рассмотрим их более подробно, когда рассмотрим подключение модулей в Node.js

В секцию Global входят такие важные классы как:

Buffer – объект используется для операций с бинарными данными.
Process – объект процесса, большая часть данных находится именно здесь.
Например свойство process.argv содержит массив аргументов командной строки. Нулевым элементом будет имя исполняемого приложения node, вторым имя самого исполняемого сценария и только потом сами параметры.

Для работы с каталогами используются следующие функции – process.cwd() возвращает текущий рабочий каталог, process.chdir() выполняет переход в другой каталог. Команда process.exit() завершает процесс с указанным в качестве аргумента кодом: 0 – успешный код, любое отличное от 0 число, но чаще всего 1 – код ошибки.

Важный метод process.nextTick(fn) запланирует выполнение указанной функции таким образом, что указанная функция будет выполнена после окончания текущей фазы(текущего исполняемого кода), но перед началом следующей фазы event loop.

process.nextTick(function() {
  console.log('NextTick callback');
}

Объект Process содержит еще много свойств и методов, с которыми можно ознакомиться самостоятельно в справочной документации к Node.js.

Модули
Для подключения сторонних модулей к вашему проекту в Node.js существует удобная система управления модулями NPM. По сути это публичный репозиторий, созданных при помощи Node.js дополнительных программных модулей.

Команда npm позволяет устанавливать, удалять или обновлять нужные вам модули, автоматически учитывая при этом все зависимости выбранного вами модуля от других дополнительных модулей. Установка модуля производится командой

npm install *имя модуля* [*ключи*]

для установки модуля всегда используется поддиректория node_modules в вашем проекте. Хотя node_modules и содержит все необходимые для запуска зависимости, распространять исходный код вместе с этой папкой не надо.

С учетом того, что все публичные NPM модули можно легко установить с помощью npm, для вашего проекта создается файл package.json с перечнем всех необходимых для работы зависимостей и потом, на сервер можно установить все нужные модули командой:

npm install

Основные ключи при установке это:

-S или --save - модуль устанавливается как основная зависимость. Означает, что модуль необходим для нормального функционирования программы.
-D или --save-dev - означает, что модуль установится как дополнительная зависимость. В основном модуль нужен для разработки и в нем нет необходимости при работе программы.
Модули относятся к трем категориям:

базовые (core modules)
файловые (file modules)
npm-модули (npm modules)
Имена базовых модулей зарезервированы; эти модули, например, fs и os, предоставляет сама среда Node.

Файловый модуль — это когда вами создается файл с экспортируемой функцией, в котором присваивалось нечто (функция, объект и т.д. ) свойству module.exports, а затем этот файл используется в других файлах вашей программы.

Модули npm — это обычные файловые модули, которые находятся в специальной папке, называемой node_modules. Когда вы используете функцию require, Node определяет тип модуля из передаваемой строки.

Если вы подключаете некий не базовый модуль moduleName, то Node.js будет искать в текущем каталоге подкаталогnode_modules. Если Node не найдет указанный каталог, то поиск будет продолжен в этом каталоге. Если снова поиск будет не успешным, то Node.js перейдет к родительскому каталогу, и снова начнет искать каталог node_modules, продолжив поиск в нем. Процесс будет повторяться, пока не будет найден модуль или достигнут корневой каталог.

Модули CommonJS
Node.js работает с системой подключения модулей CommonJS. В структурном плане, CommonJS-модуль представляет собой готовый к новому использованию фрагмент JavaScript-кода, который экспортирует специальные объекты, доступные для использования в любом коде, где необходима эта зависимость. Две главных идеи CommonJS-модулей: объект exports, содержащий то, что модуль хочет сделать доступным для других частей системы, и функцию require, которая используется одними модулями для импорта объекта exports из других.

Определим модуль module.js

const info = msg => {
  console.log(`Info: ${msg}`);
};

const log = msg => {
  console.log(`Log: ${msg}`);
};

module.exports = {
  info,
  log,
};

Конструкция module — специальный объект, который введен в Node.js ради реализации модулей Common.js. Все то, что будет присвоено его свойству exports, будет экспортироваться из этого модуля.

В основной программе main.js мы подключим эти модули и вызовем их

const logger = require('./module');

logger.info('info function');
logger.log('log function');

Здесь модуль просто экспортирует обычный объект с функциональными свойствами

Модули ECMAScript
Начиная с версии 6.х Node.js также поддерживает подключение модулей согласно стандарту ECMAScript. Но полноценно импортирование модулей заработало только с версии 14.x. Для этого мы можем пойти двумя путями. Первый дать файлам расширение .mjs, чтобы мы могли использовать модули ECMAScript или в файле package.json установить поле "type" в значение "module". Пойдем вторым путем и создадим в пустой папке командой

npm init -y

файл package.json по умолчанию и добавим туда поле "type" со значением "module"

После создадим модуль import.js

export const info = msg => {
  console.log(`Info: ${msg}`);
};

export const log = msg => {
  console.log(`Log: ${msg}`);
};

И в основной программе app.js импортируем указанный модуль и вызовем функции.

import { info, log } from './import.js';

info('info function');
log('log function');

Мы реализовали два подхода подключения модулей Common.js и ECMAScript

Работа с файлами
Модуль FileSystem отвечает за работу с файлами в Node.js. Современная инициализация модуля с промисами происходит следующим образом:

const fs = require('fs').promises;

Наиболее используемые функции, для основных операций над файлами, следующие:

fs.readFile(filename, [options]) - чтение файла
fs.writeFile(filename, data, [options]) - запись файла
fs.appendFile(filename, data, [options])- добавление в файл
fs.rename(oldPath, newPath) - переименование файла.
fs.unlink(path, callback) - удаление файла.
При операциях с файлами никогда не забываем обрабатывать ошибки. Помимо этого необходимо помнить, что параметр data в функции readFile, содержит уже упоминавшийся объект типа Buffer, содержащий последовательность прочитанных байтов, т.е. сырые данные. Самый простой способ работать с данными как со строкой, необходимо конвертировать data методом toString():

fs.readFile('readme.txt')
  .then(data => console.log(data.toString()))
  .catch(err => console.log(err.message));

Также существуют методы модуля fs с синхронными версиями, оканчивающиеся на Sync. Их необходимо подключать как

const fs = require('fs');

Но тогда все подключаемые функции не возвращают промис и им необходим callback. Синхронным функциям callback не нужен, т.к. они являются блокирующими и поэтому они не рекомендованы к применению, только если это требует текущая задача и вы четко понимаете зачем вы их используете.

Давайте напишем скрипт files.js, который будет читать текущий каталог и выводить его содержимое: имя файла, его размер и дату последнего изменения.

const fs = require('fs').promises;

fs.readdir(__dirname)
  .then(files => {
    return Promise.all(
      files.map(async filename => {
        const stats = await fs.stat(filename);
        return {
          Name: filename,
          Size: stats.size,
          Date: stats.mtime,
        };
      }),
    );
  })
  .then(result => console.table(result));

Давайте разберем этот код более подробно. Вначале мы подключаем стандартный модуль fs с промисами:

const fs = require('fs').promises;

С помощью переменной __dirname мы считываем все файлы из текущего каталога. В результате выполнения промиса в переменную files мы получим массив имен файлов и директорий из текущей директории. Затем мы возвращаем массив промисов с анализом каждого элемента этого массива. Провести анализ помогает нам переменная stats, куда мы получаем информацию о текущем файле. Мы возвращаем объект с именем файла, а также stats.mtime время последнего изменения файла и stats.size, который определяет размер файла в байтах.

Результат выполнения этого промиса, переменная result, мы отдаем функции console.table и получаем красивую таблицу при выполнении нашего скрипта в консоли

