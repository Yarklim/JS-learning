Аутентификация с логином и паролем
Вначале давайте разберемся с терминологией. Аутентификация и авторизация, что это? Эти два термина многие используют как взаимозаменяемые, однако это не совсем так. Аутентификация относится к проверке подлинности пользователя: что он тот, за кого себя выдает. Авторизация относится к определению того, к чему пользователь может получить доступ в вашем веб-приложении. Типичный пример обыкновенные пользователи и администратор который тоже авторизован, но имеет доступ не только к своей учетной записи, но и к записям других пользователей. Логически становится понятно, что в начале выполняется аутентификация, а затем устанавливается авторизация.

В этом разделе мы разработаем приложение Node.js и используем популярное промежуточное ПО аутентификации - Passport. Вначале мы разберем классический способ - использование пароля и имени пользователя. Это так называемая локальная стратегия.

Являясь промежуточным программным обеспечением, Passport легко настраивается в любом веб-приложении на основе Express так же, как мы бы настраивали любое другое промежуточное ПО Express такое как: body парсер, работа с cookie, обработка сеанса и т. д.

Стратегии аутентификации
Passport предоставляет на выбор более 500 механизмов аутентификации. Начиная от простых логин-пароль, до использования провайдеров аутентификации социальных сетей.

Все эти стратегии независимы друг от друга и упакованы как отдельные узловые модули, которые не включаются по умолчанию при установке промежуточного ПО Passport:

npm install passport

Данные наших пользователей мы будем хранить в базе данных MongoDB. Для использования локальной стратегии аутентификации нам необходимо установить необходимый модуль:

npm install passport-local

Настройка приложения
Мы будем использовать следующие зависимости для нашего проекта, которые надо установить:

npm i bcryptjs connect-flash dotenv ejs express express-session mongoose passport passport-local

Создание модели Mongoose
Поскольку мы будем сохранять данные пользователя в MongoDB, то будем использовать Mongoose в качестве ODM.

Модель пользователя в Mongoose будет следующего вида и хранить ее будем в файле schemas/user.js нашего приложения.

const mongoose = require('mongoose');
const bCrypt = require('bcryptjs');

const Schema = mongoose.Schema;

const userSchema = new Schema({
  username: String,
  email: {
    type: String,
    required: [true, 'Email required'],
    unique: true,
  },
  password: {
    type: String,
    required: [true, 'Password required'],
  },
});

userSchema.methods.setPassword = function (password) {
  this.password = bCrypt.hashSync(password, bCrypt.genSaltSync(6));
};

userSchema.methods.validPassword = function (password) {
  return bCrypt.compareSync(password, this.password);
};

const User = mongoose.model('user', userSchema);

module.exports = User;

Чтобы сохранить пользователя в базе данных и затем сравнить пароль, который он вводит, нам необходимо зашифровать пароль, так как небезопасно хранить пароли без шифрования в базе данных. Согласно википедии bcrypt — адаптивная криптографическая хеш-функция формирования ключа, используемая для защищенного хранения паролей. Разработчики: Нильс Провос и David Mazières. Функция основана на шифре Blowfish, впервые представлена на USENIX в 1999 году. Для защиты от атак с помощью радужных таблиц bcrypt использует соль (salt); кроме того, функция является адаптивной, время её работы легко настраивается и её можно замедлить, чтобы усложнить атаку перебором.

В npm репозитории существуют два популярных пакета для хеширования паролей bcrypt и bcryptjs. Отличие в том, что пакет bcrypt работает только с LTS версиями и чаще используется на продакшене, поэтому вполне возможно, что у вас стоит последняя версия node.js для обучения и он просто не будет работать. Поэтому мы используем bcryptjs без ущерба безопасности нашего приложения.

У нас есть функция setPassword которая будет шифровать пароль, и функция validPassword, которая будет проверять валидность нашего пароля.

Для подключения мы будем использовать облачную базу данных Mongo Atlas. URI (унифицированный идентификатор ресурса) для подключения к базе данных мы будем хранить в файле переменных окружения .env в переменной DB_HOST.

Теперь используя эту конфигурацию в главном файле server.js мы подключаемся к ней, используя Mongoose APIs:

const mongoose = require('mongoose');
require('dotenv').config();
mongoose.Promise = global.Promise;
mongoose.connect(process.env.DB_HOST, {
  useNewUrlParser: true,
  useCreateIndex: true,
  useUnifiedTopology: true,
});

Настройка Passport
Passport предоставляет только механизм для проверки подлинности пользователя, ответственность за реализацию остается на самом сеансе обработки, так что для этого нам надо использовать express-session. И значит в файл server.js нам надо вставить следующий код перед роутингом:

app.use(
  session({
    secret: 'secret-word',
    key: 'session-key',
    cookie: {
      path: '/',
      httpOnly: true,
      maxAge: null,
    },
    saveUninitialized: false,
    resave: false,
  }),
);
require('./config/config-passport');
app.use(passport.initialize());
app.use(passport.session());

Это необходимо сделать, чтобы сеанс нашего пользователя носил постоянный характер.

Сериализация и десериализация пользовательских экземпляров
Passport также должен сериализовать и десериализовать экземпляр пользователя из хранилища сеансов для того, чтобы обеспечить поддержку сеансов входа в систему так, чтобы каждый последующий запрос не содержал учетные данные пользователя. Для реализации этой цели есть два метода serializeUser и deserializeUser:

passport.serializeUser((user, done) => {
  done(null, user.id);
});

passport.deserializeUser((id, done) => {
  User.findById(id, (err, user) => {
    done(err, user);
  });
});

Мы их вынесем в отдельной каталог и в отдельный файл config-passport.js Внутри этих функций мы используем функцию обратного вызова done. Идентификатор пользователя, который мы указываем в качестве второго аргумента этой функции сохраняется в сеансе и позже используется для получения всего объекта через deserializeUser функцию. Функция serializeUser определяет, какие данные пользовательского объекта должны храниться в сеансе. Результат метода serializeUser прикрепляется к сеансу как req.session.passport.user. В нашем случае в req.session.passport.user будет храниться уникальный идентификатор пользователя.

Грубо говоря функция serializeUser записывает идентификатор пользователя в сессию, а deserializeUser достает этот идентификатор, извлекает объект пользователя из базы и сохраняет пользователя в запрос как req.user, откуда мы и получаем к нему доступ.

Использование стратегии Passport
Теперь мы определим стратегию Passport для обработки авторизации. Мы используем промежуточное ПО connect-flash для отображения мгновенных сообщений пользователю, если пользователь сделал ошибку.

Стратегия авторизации входа в систему выглядит следующим образом:

passport.use(
  new LocalStrategy({ usernameField: 'email' }, (email, password, done) => {
    User.findOne({ email })
      .then(user => {
        if (!user) {
          return done(null, false);
        }
        if (!user.validPassword(password)) {
          return done(null, false);
        }
        return done(null, user);
      })
      .catch(err => done(err));
  }),
);

Первый параметр для passport.use() это имя стратегии, которое будет использоваться для идентификации этой стратегии при ее дальнейшем применении. Мы опускаем этот параметр и он будет использовать значение по умолчанию как 'local'. Второй параметр это тип стратегии, которую вы хотите создать. Здесь мы используем username-password или LocalStrategy. Следует отметить, что по умолчанию LocalStrategy ожидает найти учетные данные пользователя в параметрах req.body как username и password, однако она также позволяет нам использовать любые другие именованные параметры. Поэтому мы через параметр usernameField изменяем значение username на email. Переменная конфигурации passReqToCallback позволяет нам получить доступ к request объекту в обратном вызове, тем самым позволяя нам использовать любой параметр, связанный с запросом, но в нашем примере мы ее не используем.

Далее, мы используем Mongoose API чтобы найти пользователя и проверить является ли он действительным или нет. Последний параметр в нашем обратном вызове – done. Он обозначает метод, используя который мы сигнализируем об успешности или неудаче модуля Passport. Чтобы указать на неудачу, надо чтобы либо первый параметр содержал ошибку, либо второй параметр был равен false. Чтобы указать на успех, первый параметр должен быть null, а второй должен иметь значение true, в случае чего он будет доступен в request объекте. В нашем случае мы туда помещаем объект пользователя.

Чтобы полнее представлять наше приложение, а не видеть только фрагменты кода вы можете наблюдать его в действии целиком:


NOTE
Откройте приложение в новом окне, а не в фрейме. Иначе промежуточное ПО connect-flash может не работать. Это следующая снизу кнопка - справа от кнопки 'View Source'

Создание роутов
Теперь мы определяем наши пути для приложения в модуле routes/index.js

const express = require('express');
const router = express.Router();
const passport = require('passport');
const User = require('../schemas/user');

const isLoggedIn = (req, res, next) => {
  if (req.isAuthenticated()) {
    return next();
  }
  req.flash('message', 'Авторизируйтесь');
  res.redirect('/');
};

router.get('/', (req, res, next) => {
  res.render('index', { message: req.flash('message') });
});

router.post('/login', (req, res, next) => {
  passport.authenticate('local', (err, user) => {
    if (err) {
      return next(err);
    }
    if (!user) {
      req.flash('message', 'Укажите правильный логин и пароль!');
      return res.redirect('/');
    }
    req.logIn(user, function (err) {
      if (err) {
        return next(err);
      }
      return res.redirect('/profile');
    });
  })(req, res, next);
});

router.get('/registration', (req, res, next) => {
  res.render('registration', { message: req.flash('message') });
});

router.post('/registration', async (req, res, next) => {
  const { username, email, password } = req.body;
  try {
    //создаем экземпляр пользователя и указываем введенные данные
    const user = await User.findOne({ email });
    //если такой пользователь уже есть - сообщаем об этом
    if (user) {
      req.flash('message', 'Пользователь с таким Email уже существует');
      return res.redirect('/');
    }
    const newUser = new User({ username, email });
    newUser.setPassword(password);
    //если нет - добавляем пользователя в базу
    await newUser.save();
    req.flash('message', 'Вы успешно зарегистрировались');
    res.redirect('/');
  } catch (e) {
    next(e);
  }
});

router.get('/profile', isLoggedIn, (req, res, next) => {
  console.log(req.session.passport);
  const { username, email } = req.user;
  res.render('profile', { username, email });
});

router.get('/logout', function (req, res) {
  req.logout();
  res.redirect('/');
});

module.exports = router;

Самая важная часть приведенного выше фрагмента кода - это использование passport.authenticate() для роута /login, чтобы делегировать аутентификацию для local стратегии, когда HTTP POST метод выполняется для этого пути.

Для регистрации пользователя мы используем роутер на маршруте /registration. Здесь мы снова используем Mongoose API, чтобы определить, существует ли уже пользователь с указанным email или нет. Если нет, тогда создаем нового пользователя и сохраняем о нем информацию в Mongo. В противном случае мы вернем ошибку при помощи мгновенных сообщений. Обратите внимание, что мы используем bcryptjs через функцию newUser.setPassword(password) для создания хэша пароля перед сохранением.

Создание шаблонов EJS
Наше приложение использует следующие три шаблона:

index.ejs — содержит страницу входа в систему, содержащую форму входа
registration.ejs — содержит форму для регистрации нового аккаунта
profile.ejs — это наша секретная страница, куда попасть мы можем только залогинившись
error.ejs — используется для вывода ошибок
Для стилизации наших шаблонов мы частично используем Bootstrap.

Обратите внимание, что в шаблонах index.ejs и registration.ejs мы используем такой кусок кода

<% if (message) { %>
<h4><%= message %></h4>
<% } %>

Он используется, чтобы выводить мгновенные сообщения для пользователя в случае ошибок. Попробуйте создать двух пользователей с одинаковым email и увидите результат.

email exist

Осуществление функции выхода из системы
Passport добавляет определенные свойства и методы к объектам запроса и ответа. И, чтобы выполнить разлогирование пользователя мы используем, метод request.logout() он делает недействительным сеанс пользователя.

router.get('/logout', (req, res) => {
  req.logout();
  res.redirect('/');
});

Защита путей. Авторизация
Но главное для нас, что Passport дает возможность защищать доступ к пути, который должен быть недоступным для анонимного пользователя. Это означает, что если какой-либо пользователь попытается получить доступ к /profile без аутентификации в приложении, он будет перенаправлен на домашнюю страницу, с предложением залогиниться

router.get('/profile', isLoggedIn, (req, res, next) => {
  const { username, email } = req.user;
  res.render('profile', { username, email });
});

Как видим преждем чем выполнится обработчик роута /profile выполняется функция промежуточной обработки isLoggedIn

const isLoggedIn = (req, res, next) => {
  if (req.isAuthenticated()) {
    return next();
  }
  req.flash('message', 'Авторизируйтесь');
  res.redirect('/');
};

Эта функция использует еще один метод Passport как isAuthenticated, который принимает значение true если пользователь прошел аутентификацию.

Мы рассмотрели базовый пример аутентификации с помощью логина и пароля, где в качестве логина выступает email пользователя