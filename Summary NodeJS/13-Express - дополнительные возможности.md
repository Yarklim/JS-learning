Шаблонизаторы. EJS
MVC и шаблонизация
Шаблонизация тесно связана с концепцией MVC, которая заключается в разделении логики, данных и представления. В MVC-приложениях пользователь запрашивает нужный ресурс на сервере, затем контроллер или роутер запрашивает данные приложения у модели (базы данных) и передает эти данные представлению (шаблону), которое осуществляет окончательное форматирование данных для конечного пользователя. MVC-представления реализуются с помощью языков шаблонизации. При использовании шаблонизации, представление передает значения в шаблон, полученные из модели, и указывает файл шаблона, определя­ющий способ отображения этих значений.

template

EJS шаблоны
EJS шаблонизатор достаточно популярен и отличается быстрой компиляцией и рендерингом. Использует простые теги шаблона: <% %> для подстановки данных. Можно использовать и свои разделители например, замените [? ?] вместо <% %>. Есть возможность разбивать большой шаблон на подшаблоны. Поставляется с CLI. Поддержка шаблонизации как на стороне сервера, так и на стороне браузера. Есть статическое кеширование шаблонов. И главное соответствует системе Express View и легко подключается к фреймворку Express.

В процессе рендеринга EJS экранирует (escapes) все специальные символы в контекстных значениях и заменяет их кодами HTML-сущностей. Это предотвращает атаки межсайтового выполнения сценариев (Cross-Site Scripting, XSS), это когда хакер пытается в качестве данных отправить вредоносный код JavaScript с целью, что этот код будет выполнен при выводе данных в браузере другого пользователя. Например мы вводим вредоносный код в чате и он выполняется у всех пользователей чата.

EJS использует специальные теги в шаблонах, куда мы хотим подставить данные или код

Тег	Описание
<%	для потока управления, без вывода, в основном вспомогательный код JavaScript
<%_	Whitespace Slurping удаляет все пробелы перед ним
<%=	Выводит значение в шаблон (экранированный HTML)
<%-	Выводит неэкранированное значение в шаблон, не безопасная операция используйте ее осторожно
<%#	Тег комментария, без выполнения, без вывода
<%%	Выводит литерал <%
%>	Простой конечный тег, которым закрываем все предыдущие теги
_%>	Конечный тег Whitespace Slurping, удаляет все пробелы после него
Пример
Для этого примера необходимо установить два пакета:

npm i express ejs

Пусть существует необходимость вывести таблицу на страницу в браузере. Код приложения будет следующим

// ejs template example

const express = require('express');
const app = express();

app.set('views', './views');
app.set('view engine', 'ejs');

const users = [
  {
    name: 'Tedy',
    age: 20,
    species: 'student',
  },
  {
    name: 'Adam',
    age: 32,
    species: 'worker',
  },
];

app.get('/', (req, res) => {
  res.render('index', { users });
});

app.listen(3000, () => console.log('Example app listening on port 3000!'));

Здесь достаточно все просто. Мы указываем Express используемый шаблонизатор, после есть массив пользователей которых необходимо отрендерить на странице, а он например может быть большим в несколько сот строк и пагинация например не предусмотрена.

В обработчике корневого маршрута мы рендерим шаблон функцией render, она принимает два параметра. Первый параметр это имя шаблона, который необходимо отрендерить. Второй параметр это объект с данными, которыми мы пробрасываем в шаблон, наш список пользователей. Сам шаблон index.ejs должен иметь следующий вид:

<!DOCTYPE html>
<html>
  <head>
    <title>EJS compilation demo</title>
    <style></style>
  </head>
  <body>
    <% function userView(user, i) { %>
    <tr>
      <td><%= i %></td>
      <td><%= user.name %></td>
      <td><%= user.age %></td>
      <td><%= user.species %></td>
    </tr>
    <% } %>
    <table border="1">
      <tr>
        <td>#</td>
        <td>Name</td>
        <td>Age</td>
        <td>Species</td>
      </tr>
      <% users.map(userView) %>
    </table>
  </body>
</html>

Код который выводит таблицу у нас следующий

<table border="1">
  <tr>
    <td>#</td>
    <td>Name</td>
    <td>Age</td>
    <td>Species</td>
  </tr>
  <% users.map(userView) %>
</table>

Тут достаточно все просто, мы создаем таблицу ее шапку, а вот за вывод строк таблицы отвечает мапинг массива users, который мы пробросили в шаблон. Функция map принимает функцию userView, которую мы описали чуть выше. В принципе это обыкновенный JavaScript, и мы видим, что EJS легко позволяет нам комбинировать его со своими тегами.

ejs example

Шаблонизация широко использовалась до появления современных фронтенд фреймворков по типу React, Angular и т.д. Но она до сих пор остается мощным средством для серверного рендеринга.

Работа с cookie
HTTP протокол не сохраняет состояние запроса и когда вы переходите по страницам сайта то сервер не может знать, что это один и тот же пользователь. И здесь есть определенная проблема - не возможно залогинится на сайт, сохранить настройки сайта при переходе между страницами и т.д.

Для таких вещей и существуют cookie-файлы и сеансы, которые позволяют поверх протокола HTTP сохранять состояние пользователя. Смысл cookie-файла достаточно прост сервер отправляет некий фрагмент информации до 4 кб, а браузер хранит его на стороне клиента как файл. Есть определенный промежуток времени хранения этого файла. Что касается хранимой информации, то часто это просто какой-то уникальный идентификатор для пользователя.

Для работы с cookie-файлами существует модуль cookie-parser. Он позволяет получать данные cookie-файла, которые хранит брау­зер у пользователя сайта. Модуль cookie-parser поддерживает разбор обычных и подписанных cookie. По умолчанию используются обычные неподписанные cookie, доступ к которым на сервере мы получим через объект req.cookies. Для работы с подписанными cookie нам при подключении модуля надо передать секретную строку.

При установке cookie-файла вы можете указать следующие опции.

httpOnly - почти всегда значение этого параметра устанавливается в true и говорит о том, что cookie-файл будет изменяться только сервером. Таким образом мы предотвращаем XSS-атаки от JavaScript со стороны клиента

path - путь, на который распространяется действие данного cookie-файла. По умолчанию используется путь /, он распространяется на все страницы сайта.

domain - позволяет привязывать cookie-файлы к конкретным поддоменам. Мы можем установить cookie-файл только для домена на котором работает ваш сервер.

maxAge - определяет, сколько времени в миллисекундах клиент должен хранить cookie- файл до его удаления. Если опция не указана, cookie-файл будет удален при закрытии браузера.

secure - работа с cookie-файлами должна проводиться только через защищенное (HTTPS) соединение.

signed - необходимо установить в true, чтобы подписать данный cookie-файл. После этого он становится доступным в res.signedCookies вместо res.cookies. Поддельные cookie-файлы будут не приняты сервером

Давайте добавим работу с cookie в предыдущий пример. Но прежде надо разобраться как просматривать cookie в браузере. Большинство браузеров дают возможность просматривать cookie-файлы и хранимые ими значения. А значит вы прекрасно понимаете, что любой пользователь в ручном режиме может просмотреть наши cookie, изменить или удалить. В Chrome откройте инструменты разработчика и выберите закладку Application. В меню слева вы увидите пункт Cookies. Разверните его и увидите в списке сайт, который мы просматриваем в текущей вкладке. Нажмите на url указанного сайта и увидим все связанные с этим сайтом cookie-файлы.

cookie

В моем случае список пока пустой.

В нашем приложении, которое для нас создал express-generator работа с cookie-parser уже добавлена в приложение. Нам остался только один момент - подключить работу с переменными окружения

require('dotenv').config();

и добавить секретное слово при подключении парсера.

app.use(cookieParser(process.env.SECRET_KEY));

В файл шаблона index.ejs мы добавим следующий код

<p>
  <a href="/setcookie">Установить cookie</a>
</p>
<p>
  <a href="/clearcookie">Удалить cookie</a>
</p>

Это две ссылки. По этим двум роутам мы будем добавлять cookie и удалять их для текущего клиента. Добавим обработчики для этих роутов.

router.get('/setcookie', (req, res, next) => {
  res.cookie('my_cookie', 'hello world!');
  res.cookie('my_signed_cookie', 'hello world!', { signed: true });
  res.redirect('/');
});

router.get('/clearcookie', (req, res, next) => {
  console.log(req.cookies['my_cookie']);
  console.log(req.signedCookies['my_signed_cookie']);
  res.clearCookie('my_cookie');
  res.clearCookie('my_signed_cookie');
  res.redirect('/');
});

Установка cookie достаточно проста. Через объект res мы вызываем метод cookie, куда передаем, имя куки, ее значение и объект с опциями, которые мы рассмотрели выше. Если мы кликнем по ссылке то увидим появившиеся в панели разработчика наши установленные cookie.

cookie

Обратите внимание, что подписанная кука зашифрована. Очищение cookie производится методом res.clearCookie в которую мы передаем имя куки. А вот, чтобы прочитать куку, которая пришла от клиента, мы используем методы объекта req. Для обычной куки

req.cookies['имя куки'];

а для подписанной

req.signedCookies['имя куки'];

Полный код приложения:

ВНИМАНИЕ!
Чтобы приложение полноценно работало, обязательно откройте его в отдельном окне. Сейчас оно работает как фрейм на странице.


Закрепить материал по работе с cookie можно определением из википедии

ОПРЕДЕЛЕНИЕ
Cookie - небольшой фрагмент данных, отправленный веб-сервером и хранимый на компьютере пользователя. Веб-клиент (обычно веб-браузер) всякий раз при попытке открыть страницу соответствующего сайта пересылает этот фрагмент данных веб-серверу в составе HTTP-запроса. Применяется для сохранения данных на стороне пользователя, на практике обычно используется для:

аутентификации пользователя;
хранения персональных предпочтений и настроек пользователя;
отслеживания состояния сеанса доступа пользователя;
сведения статистики о пользователях.

Работа с сессией
Сессия более удобный способ сохранения состояния для сервера. Чтобы реализовать сессию надо хранить какую-то метку на стороне клиента, иначе сервер просто не поймет, что запросы идут от одного и того же клиента. А значит cookie-файл с уникальным идентификатором как раз подходит нам и сервер используя идентификатор сможет реализовать сессию.

Модуль express-session предоставляет нам API для реализации сессии. Рассмотрим настройку этого модуля Он принимает конфигурационный объект со следующими опциями.

resave - обычно устанавливают его в состояние false. Параметр отвечает за сохранение в хранилище сессии, даже если запрос не изменялся.

saveUninitialized - тоже обычно устанавливают в состояние false, поскольку спрашивают пользователя разрешение на установку cookie-файла. Параметр в true приводит к сохранению новых сессий в хранилище, даже если они не менялись.

secret - секретный ключ для подписания cookie-файла идентификатора сессии.

key - имя cookie-файла, по умолчанию connect.sid, в нем хранится уникальный идентификатор сессии.

store - это экземпляр сеансового хранилища. По умолчанию сессия хранится в памяти - экземпляр MemoryStore, что вполне подходит для разработки и обучения, наших текущих целей. Но в продакшене мы используем в качестве хранилища базу данных, чаще всего это Redis (возможно и MongoDb или другая база). Это делается для того, чтобы при перезагрузке сервера мы не теряли текущие сеансы пользователей.

cookie - те же настройки, что мы использовали для модуля cookie-parser

Давайте в наше приложение добавим сеанс. Он будет выводить счетчик просмотра страницы для текущего пользователя.

Сначала мы инициализируем сеансовый промежуточный компонент с необходимыми параметрами: secret, resave и saveUninitialized.

app.use(
  require('express-session')({
    resave: false,
    saveUninitialized: false,
    secret: process.env.SECRET_KEY,
  }),
);

Управление данными в express-session реализовано достаточно просто. Мы присваиваем объекту req.session, необходимые нам свойства. Они сохраняются после выполнения запроса. Эти свойства будут загружены при поступлении по­следующих запросов от того же пользователя.

Чтобы сохранить количество просмотров надо задать req.session.views необходимое значение. И при обращении к свойству req.session.views в последующих запросах, нам доступно предыдущее значение и мы будем его просто каждый раз увеличивать.

В файл шаблона добавим следующую строку

<p>Количество просмотров этой страницы: <%= views %></p>

Перепишем обработчик роутера для главной страницы

router.get('/', (req, res, next) => {
  req.session.views = req.session.views === void 0 ? 0 : ++req.session.views;
  res.render('index', {
    title: 'Simple express app',
    views: req.session.views,
  });
});

И теперь каждый раз обновляя страницу счетчик будет увеличиваться на единицу.

Если вам для каких-то целей нужно реализовать уничтожение сессии, то необходимо вызвать

req.session.destroy(function (err) {
  // cannot access session here
});

Пример приложения:

ВНИМАНИЕ!
Чтобы приложение полноценно работало, обязательно откройте его в отдельном окне. Сейчас оно работает как фрейм на странице.

