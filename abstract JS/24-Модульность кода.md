Node.js
Node.js - легкая и эффективная среда выполнения JavaScript. Позволяет писать высокопроизводительные серверные приложения и инструменты. Node.js построен на JavaScript-движке V8 и написан на C++.

Изначально Node.js создавался как серверное окружение для приложений, но разработчики начали использовать его для создания инструментов, помогающих автоматизировать выполнение локальных задач. В итоге возникшая вокруг Node.js новая экосистема инструментов, привела к трансформации процесса фронтенд-разработки.

Установка
Чтобы установить последнюю стабильную версию, перейдите на официальную страницу, скачайте LTS-инсталлятор и следуйте указаниям. Есть установщики для всех популярных операционных систем - Windows, MacOS и Linux.

ИНТЕРЕСНО
Пользователям Windows необходимо выбрать чекбоксы для установки всех дополнительных инструментов кроме Chocolatey. Это установит Python и всевозможные вспомогательные утилиты и компиляторы.

После установки в терминале будет доступна команда node. Для того чтобы убедиться, что установка прошла успешно, проверьте версию, запустив в консоли команду node с флагом version.

node --version

JavaScript вне браузера
Node.js позволяет выполнять JavaScript-код вне браузера. Откройте любой терминал и выполните команду node, запустится REPL (read-eval-print loop) - интерактивная среда выполнения JS-кода. Выведем что-то в консоль.

nodejs log
ИНТЕРЕСНО
Для того чтобы выйти из REPL, нажмите комбинацию Ctrl + C на Windows и Control + C на MacOS.

Теперь создадим папку node-tut, а в ней файл index.js с кодом, который мы писали в REPL. Для запуска нужно открыть терминал и перейти в папку node-tut в которой лежит index.js.

// index.js
const message = "NodeJS in amazing!";
console.log(message);

Теперь в консоли запускаем файл с помощью команды node index.js и получаем тот же результат - вывод строки непосредственно в терминале.

file execution by nodejs
В этом и заключается суть Node.js - возможность выполнять JavaScript вне браузера. Таким образом можно писать целые приложения, например бэкенд или утилиты не зависящие от браузера.

Пакетный менеджер npm
Чтобы использовать все богатство инструментов (или пакетов) Node.js нам нужна возможность устанавливать и управлять ими. Для этого создан NPM (node package manager) - пакетный менеджер Node.js. Он устанавливает нужные пакеты и предоставляет удобный интерфейс для работы с ними.

NPM состоит из трех основных компонентов:

Сайт npmjs.com - используется для поиска и ознакомления с документацией пакетов.
Интерфейс командной строки (CLI) - запускается из терминала и предоставляет набор команд для работы с реестром и пакетами. Позволяет создавать скрипты для запуска в терминале.
Реестр пакетов (registry) - большая общедоступная база данных инструментов разработки (пакетов).
Пакет (package) - небольшая JavaScript библиотека, решающая специфическую задачу. Пакеты пишут сами разработчики и делятся с сообществом. Такой подход упрощает жизнь, потому что не нужно изобретать колесо, все колеса уже давно лежат на полках реестра и готовы к использованию.

ИНТЕРЕСНО
Пакеты абстрагируют реализацию функционала, предоставляя разработчику удобный интерфейс. Это делает код чище, читабельнее и позволяет легче его поддерживать.

Команды NPM
Сразу перечислим основные команды и будем последовательно использовать и рассматривать в деталях.

npm init - инициализирует npm в проекте и создает файл package.json
npm install - устанавливает все зависимости перечисленные в package.json
npm list --depth=0 - выведет в терминале список локально установленных пакетов с номерами их версий, без зависимостей
npm install [package-name] - установит пакет локально в папку node_modules
npm uninstall [package-name] - удалит пакет, установленный локально и обновит package.json
npm start и npm test - запустит скрипт start или test, расположенный в package.json
npm run [custom-script] - запустит кастомный скрипт, расположенный в package.json
npm outdated - используется для поиска обновлений, обнаружит совместимые версии программно и выведет список доступных обновлений
npm update - обновит все пакеты до максимально разрешенной версии
Документация NPM

Инициализация проекта
Каждый проект начинается с создания файла package.json - он отслеживает зависимости, содержит служебную информацию, позволяет писать npm-скрипты и служит инструкцией при создании нового проекта на основе уже готовых настроек. Создать файл package.json можно npm-командой init, тем самым инициализировав проект в текущей папке.

npm init

Вам будет предложено ввести название проекта, версию, описание и т. д. Можно просто нажимать Enter до тех пор, пока не будет создан package.json и размещен в папке проекта. Чтобы не нажимать Enter, пропуская пустые поля, используется команда init с флагом --yes. Флаг - дополнительная настройка для команды.

npm init --yes

ИНТЕРЕСНО
У каждого флага есть псевдоним - его сокращённая запись. Псевдоним флага --yes это -y, поэтому комманды npm init --yes и npm init -y делают одно и тоже.

Будет создан package.json со значениями по умолчанию. Чтобы установить эти значения, в терминале последовательно выполните следующие команды, подставив свое имя и почту.

npm config set init.author.name "YOUR_NAME"
npm config set init.author.email "YOUR_EMAIL"

npm init
Можно редактировать файл package.json вручную или выполнить npm init ещё раз. Если открыть package.json в редакторе, он будет выглядеть примерно так. Это всего лишь метаданные о проекте.

package.json
{
  "name": "node-tut",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "Alexander Repeta <mycoolemail@mail.com>",
  "license": "ISC",
  "keywords": [],
  "description": ""
}

npm-скрипты
Скрипты позволяют запускать на исполнение установленные пакеты. Используя npm-скрипты, можно создавать целые системы сборки проекта. Автоматизируем запуск index.js. Для этого в файле package.json в поле scripts добавим скрипт запуска start.

package.json
{
  "scripts": {
    "start": "node index.js"
  }
}

Теперь мы можем запустить его в терминале командой npm start.

npm start
ВНИМАНИЕ
Если создать скрипт с любым другим именем, кроме start или test, он будет запускаться как npm run имя-скрипта - не забудьте run. Ознакомтесь с документацией - How npm handles the "scripts" field.

Установка пакетов
Одна из возможностей, которые предоставляет npm - установка пакетов, которые извлекаются из реестра и распаковываются в папку node_modules в корне проекта. После того как файл package.json создан, можно добавить зависимости в проект.

Зависимостью называют npm-пакет, который используется при разработке. Это всевозможные утилиты и библиотеки. Установим библиотеку validator.js для валидации строк, например ввода пользователя в поля формы.

npm install validator

NPM загрузил validator и поместил его в node_modules - папку, в которой будут находиться все внешние зависимости.

ВНИМАНИЕ
Не добавляйте папку node_modules в систему контроля версий, у всех разработчиков она будет своя. Если вы используете Git, не забывайте добавить папку node_modules в файл .gitignore.

Обратите внимание на созданный файл package-lock.json - это журнал снимков дерева зависимостей проекта. Он гарантирует, что команда разработчиков использует одни и те же версии зависимостей. NPM автоматически обновляет его при добавлении, удалении и обновлении пакетов.

В package.json появилась новая зависимость в поле dependencies. Это означает, что validator версии 11.1.0 был установлен как зависимость и готов к работе. Пакеты постоянно обновляются, ваша версия может отличаться.

package.json
{
  "dependencies": {
    "validator": "^11.1.0"
  }
}

Для того чтобы получить интерфейс пакета в Node.js-коде, необходимо вызвать функцию require("имя-модуля"), аргументом передав ей имя модуля без определения пути - это называется абсолютный импорт. Путь не нужен, так как по умолчанию поиск модуля будет происходить в папке node_modules. Результатом своего выполнения функция вернет интерфейс модуля - объект с методами или просто функцию, зависит от пакета.

index.js
const validator = require("validator");

const validateEmail = email => {
  return validator.isEmail(email);
};

console.log(
  "Is mango@mail.com a valid email?: ",
  validateEmail("mango@mail.com")
);

console.log(
  "Is Mangozedog.com a valid email?: ",
  validateEmail("Mangozedog.com")
);

Выполнив в терминале npm start получим.

Is mango@mail.com a valid email?: true
Is Mangozedog.com a valid email?: false

Удаление пакетов
Предположим, что установленная в предыдущем примере версия validator вызывает проблемы с совместимостью. Мы можем удалить этот пакет и поставить более старую версию.

npm uninstall validator

Установка определенной версии пакета
Теперь установим нужную версию validator. В команде установки номер версии указывается после символа @.

npm install validator@1.0.0

ИНТЕРЕСНО
Установка пакетов определенный версии используется в коммерческих проектах для того, чтобы гарантировать работу кодовой базы и возможность долгосрочной поддержки. Вы можете устанавливать самые последние версии.

Типы зависимостей
Представьте торт, для его приготовления шефу нужны продукты, именно они войдут в состав торта. Но для приготовления понадобятся и инструменты вроде мисок, ложек, лопаток и т. п. А еще на кухне есть столы и печи, холодильники и т. д. - то, что используется для приготовления любого блюда, общие инструменты которые есть на кухне.

То же самое и с зависимостями проекта - некоторые будут использованы в результирующем продукте, другие необходимы только на стадии разработки, а есть такие, что необходимо использовать вне зависимости от проекта.

Именно для этого у команд npm install и npm uninstall есть три флага.

--save - указывает, что добавляется зависимость, которая войдет в финальный продукт. Пакет будет установлен локально, в папку node_modules и будет добавлена запись в поле dependencies в package.json.
--save-dev - указывает, что добавляется зависимость разработки. Пакет будет установлен локально, в папку node_modules, и будет добавлена запись в поле devDependencies в package.json.
--global - указывает, что добавляется глобальная зависимость, то есть инструмент, который доступен для любого проекта. Пакет будет установлен глобально (в систему).
ИНТЕРЕСНО
Если не указывать флаг, по умолчанию будет использован --save.
При удалении пакета необходимо указывать правильный флаг, такой же как при установке.
Не устанавливайте пакеты глобально если вы работаете на проекте с другими разработчиками.
Управление версиями пакетов
Пакеты имеют связанный с ними номер версии. Номера версий соответствуют стандарту SemVer.

npm outdated - используется для поиска обновлений, обнаружит совместимые версии программно.
npm update - обновит все пакеты до максимально разрешенной версии.
npm update [имя-пакета] - обновит указанный пакет.
ИНТЕРЕСНО
Если вы не доверяете машинам или хотите какую-то определённую версию пакета, можно открыть package.json и вручную поменять версии пакетов, после чего выполнить npm install.

Управление кэшем
После установки пакета npm сохраняет его копию в кэше, поэтому при следующей его установке вам не нужно опять скачивать его из интернета. Кэш хранится в папке .npm вашего домашнего каталога.

Эта папка со временем засоряется старыми пакетами и иногда ее полезно очищать, не слишком часто (пару раз в год), кеширование полезно, так как сокращает время установки уже использованных пакетов.

npm cache clean

Модульность кода
Концепция модулей как способа организации кода существовала давно. С ростом проекта и его кодовой базы ее пытаются разбить на файлы, в каждом из которых описывается отдельный функционал.

Модульный код помогает в организации, обслуживании, тестировании и, самое главное, управлении зависимостями. Наиболее важные преимущества модулей - это поддерживаемость, пространство имен и повторное использование.

Поддерживаемость - хорошо разработанный модуль призван максимально снизить зависимость от других частей кода. Это позволит расширять функционал приложения не опасаясь нарушить его работу в целом. Обновление одного модуля намного проще, если модуль самодостаточен.

Пространство имен - переменные, не входящие в область видимости функции, являются глобальными. Из-за этого обычно происходит загрязнение пространства имен, где полностью несвязанный код разделяет глобальные переменные. Модули позволяют избежать загрязнения пространства имен, создавая отдельную область видимости для переменных.

Повторное использование - все разработчики копировали готовый код в новые проекты, изменяя его под специфику проекта. Это, очевидно, огромная трата времени. Намного лучше когда есть модуль, который можно повторно использовать снова и снова без необходимости знать что-либо об окружении в котором он используется.

Сборка модулей
Сборка модулей - это процесс конкатенации группы модулей и их зависимостей в один или группу файлов.

Обычно код делят на папки и файлы, к тому же необходимо подключить внешние библиотеки. В результате каждый из этих файлов должен быть включен в основной HTML-файл в теге <script>, который затем загружается браузером.

Наличие отдельных тегов <script> для каждого файла означает, что браузер будет загружать каждый файл по отдельности, что негативно сказывается на скорости загрузки страницы. Чтобы обойти эту проблему, файлы объединяются в один или пару файлов, чтобы уменьшить количество запросов. Но остается проблема управления зависимостями между модулями.

Если используются системы модулей, такие как CommonJS или ESM, необходимо использовать инструмент для их преобразования в правильно упорядоченный, доступный браузеру код. Именно здесь вступают в действие Webpack и другие бандлеры (от английского bundle).

ECMAScript Modules (ESM)
До недавнего времени в языке не было встроенной модульной системы. ESM имеют компактный декларативный синтаксис и возможность асинхронной загрузки. ES-модуль - это многократно используемый фрагмент JS-кода, который экспортирует определенные объекты, делая их доступными для других модулей.

greeter.js
const helloMessage = "hello!";
const goodbyeMessage = "goodbye!";

export const hello = () => helloMessage;
export const goodbye = () => goodbyeMessage;

index.js
import { hello, goodbye } from "./greeter";

console.log(hello()); // "hello!"
console.log(goodbye()); // "goodbye!"

Каждый JS-файл хранит код в уникальном контексте модуля и импортирует необходимые ему зависимости и экспортирует все, что должно быть импортировано другими модулями. Операции экспорта/импорта реализованы конструкциями import и export. Есть два очевидных преимущества этого подхода - предотвращение загрязнения глобального пространства имен и явное указание зависимостей.

Новая система модулей отличается от CommonJS и других, прежде всего тем, что это стандарт. А значит, со временем, будет полностью поддерживаться браузерами нативно, без дополнительных инструментов. Однако сейчас браузерная поддержка не полная, поэтому ESM используются в сочетании с инструментами сборки модулей, такими как Webpack, Parcel и другими.

ИНТЕРЕСНО
ESM разработаны с учетом статического анализа. Это значит, что при импорте модулей, импорт обрабатывается во время компиляции, то есть до запуска скрипта. Это позволяет удалять экспорт, который не используется другими модулями, прежде чем запускать скрипт, что может привести к значительной экономии веса JS-файла, уменьшив нагрузку на браузер. Это называется tree shaking и выполняется бандлерами автоматически при сборке JS кода.

Named export
Модуль может экспортировать несколько сущностей, которые отличаются своими именами и называются именованными экспортами. Чтобы импортировать их в другой модуль, необходимо знать имена экспортируемых сущностей, которые мы хотим импортировать.

Первый способ - это использовать ключевое слово export перед всеми сущностями, которые необходимо экспортировать. Они будут добавлены как свойства в экспортируемый объект. При импорте мы деструктуризируем свойства из импортируемого объекта.

my-module.js
const sqrt = Math.sqrt;
export const square = x => x * x;
export const diag = (x, y) => sqrt(square(x) + square(y));

main.js
import { square, diag } from "./path/to/my-module";

console.log(square(11)); // 121
console.log(diag(4, 3)); // 5

Второй способ - это явно указать объект со свойствами для экспорта.

my-module.js
const sqrt = Math.sqrt;
const square = x => x * x;
const diag = (x, y) => sqrt(square(x) + square(y));

export { square, diag };

main.js
import { square, diag } from "./path/to/myModule";

console.log(square(11)); // 121
console.log(diag(4, 3)); // 5

Следующий синтаксис импортирует все экспорты модуля как объект с указанным именем. Это называется namespace import.

main.js
import * as myModule from "./path/to/my-module";

console.log(myModule.square(11)); // 121
console.log(myModule.diag(4, 3)); // 5

Default export
Часто модуль экспортирует всего одну сущность, такой экспорт удобен для импорта. Экспорт по умолчанию - самое главное экспортируемое значение, которое может быть чем угодно: переменной, функцией, классом и т. д.

my-func.js
export default function myFunc() {
  // ...
}

my-class.js
export default class MyClass {
  // ...
}

main.js
import myFunc from "./path/to/my-func";
import MyClass from "./path/to/my-class";

myFunc();

const inst = new MyClass();

Используйте именованный экспорт, когда необходимо экспортировать несколько сущностей, а экспорт по умолчанию - при экспорте одной сущности. Хотя и можно использовать экспорт по умолчанию и именованный экспорт в одном файле, хорошей практикой будет выбрать только один стиль для каждого модуля.

Знакомство с Webpack
Webpack - это сборщик JS-модулей, менеджер модульных зависимостей, который анализирует дерево зависимостей и создает один или несколько результирующих файлов, содержащих всю кодовую базу проекта. Выстраивает порядок подключения модулей, собирает, минифицирует, запаковывает и многое другое.

Dependency graph
Webpack стал одним из самых важных инструментов веб-разработчика. В первую очередь - это менеджер модульных зависимостей приложения и сборщик JS-файлов, но он может трансформировать все ресурсы (HTML и CSS, SASS и т. п.), оптимизировать изображения, компилировать шаблоны, запускать локальный веб-сервер для разработки и многое другое.

Принцип работы
Предположим, у нас есть приложение, которое может выполнять две простые математические задачи: суммировать и умножать. Мы решили разделить эти функции на отдельные файлы (модули) для упрощения поддержки кодовой базы. Тогда в index.html скрипты будут подключены в такой последовательности.

index.html
<script src="sum.js"></script>
<script src="multiply.js"></script>
<script src="index.js"></script>

Допустим код из sum.js используется в multiply.js и index.js, а код из multiply.js используется только в index.js. Покажем иерархию зависимостей на простой диаграмме.

Dependencies
Если ошибиться в последовательности подключения скриптов в index.html, то есть если index.js подлючен перед любой из других зависимостей или если sum.js добавлен после multiply.js - будут ошибки. Теперь представим, что мы масштабируем это до реального, полностью рабочего приложения - могут быть сотни зависимостей. Сохранение порядка подключения станет кошмаром.

Webpack преобразует зависимости в модули и сошьет в один или несколько файлов. Каждый модуль будет иметь закрытое пространство имен и подключаться в нужное время, в правильном порядке.

bundle
Gulp все еще занимает достойное место в инструментарии разработчика и для некоторых проектов, функционал Webpack не нужен, хотя он может отлично работать в связке с ним. Несмотря на то, что кривая обучения может быть выше при более сложных настройках, Webpack незаменим если вы используете современные библиотеки и фреймворки для разработки, такие как React, Vue, Angular и т. д.