Объектно-ориентированное программирование
Процедурное программирование - набор не связанных явно функций и переменных для хранения и обработки информации. Этот подход прост и прямолинеен и подходит для задач где нет тесно связанных сущностей (данных и функций для их обработки).

procedural code
Рассмотрим пример процедурного кода где есть переменные и функция для подсчета результата.

const baseSalary = 30000;
const overtime = 10;
const rate = 20;

const getWage = (baseSalary, overtime, rate) => {
  return baseSalary + overtime * rate;
};

getWage(baseSalary, overtime, rate);

Объектно-ориентированное программирование (ООП) - методология, основанная на представлении программы в виде совокупности объектов, каждый из которых содержит данные (свойства) и методы для взаимодействия с ними.

object-oriented code
Используем ООП, собрав данные в объект employee.

const employee = {
  baseSalary: 30000,
  overtime: 10,
  rate: 20,
  getWage() {
    return this.baseSalary + this.overtime * this.rate;
  },
};

employee.getWage();

При таком подходе у метода нет параметров, используются свойства объекта, которые задаются при создании объекта и, возможно, так же изменяются другими методами. На выходе получаем сущность с простым интерфейсом, что понижает сложность программы.

ИНТЕРЕСНО
Идеологически, ООП - это подход к программированию как к моделированию, решающий основную задачу - структурирование информации с точки зрения управляемости, что существенно улучшает контроль процесса моделирования.

Сущности ООП
Представьте себе, что мы проектируем автомобиль. У него будет двигатель, четыре колеса, бензобак и т. д. Автомобиль должен иметь возможность заводиться, набирать и сбавлять скорость. Мы знаем как взаимодействует двигатель и колёса, то есть согласно каким законам взаимодействуют разные части машины.

Класс
Мы описываем все запчасти из которых состоит автомобиль, то каким образом эти запчасти взаимодействуют между собой и что должен сделать водитель, чтобы машина затормозила, включились фары и другое. Результатом нашей работы будет некоторый эскиз (шаблон, схема). Мы только что разработали то, что в ООП называется класс.

Класс - способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния, а также правила для взаимодействия с данной сущностью (контракт).

В нашем случае, класс описывает сущность – автомобиль. Свойствами класса будут двигатель, колеса, фары и т. д. Методами класса будут открыть дверь, завести двигатель, увеличить скорость и т. п.

Экземпляр
Мы спроектировали чертежи и машины, разработанные по ним, сходят с конвейера. Каждая из них точно повторяет чертеж, все системы взаимодействуют именно так, как мы спроектировали, но каждая машина уникальна. Они все имеют номер кузова и двигателя, но все номера разные, автомобили различаются цветом, отделкой салона. Эти автомобили являются экземплярами класса.

Экземпляр (объект) - это отдельный представитель класса, имеющий конкретное состояние и поведение, полностью определяемое классом. Это то, что создано по чертежу, то есть по описанию из класса.

Говоря простым языком, объект имеет конкретные значения свойств и методы, работающие с этими свойствами на основе правил, заданных в классе. В данном примере, если класс - это некоторый абстрактный автомобиль на чертеже, то объект - это конкретный автомобиль, стоящий у нас под окнами.

Интерфейс
Когда мы подходим к автомату с кофе или садимся за руль автомобиля, существует некоторый набор элементов управления, с которыми мы можем взаимодействовать.

Интерфейс - это набор свойств и методов класса, доступных для использования при работе с экземпляром.

По сути, интерфейс описывает класс, чётко определяя все возможные действия над ним. Хороший пример интерфейса - приборная панель автомобиля, которая позволяет вызвать такие методы как увеличение скорости, торможение, поворот, переключение передач, включение фар и т. п.

При описании интерфейса класса очень важно соблюсти баланс между гибкостью и простотой. Класс с простым интерфейсом будет легко использовать, но будут существовать задачи, которые с помощью него решить будет не под силу.

Если интерфейс будет гибким, то скорее всего, он будет состоять из достаточно сложных методов с большим количеством параметров, которые будут позволять делать очень многое, но его использование будет сопряжено с большими сложностями и риском совершить ошибку, что-то перепутав.