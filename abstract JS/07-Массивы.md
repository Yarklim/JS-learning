Массивы
Массив - структура данных для хранения и манипулирования коллекцией индексированных значений. Используeтся для хранения упорядоченных коллекций данных, например списка курортов, товаров, клиентов в отеле и т. п.

Создание
Массив объявляется открывающей и закрывающей квадратной скобками [] - литералом массива. Внутри скобок каждый элемент массива разделяется запятой.

const clients = ["Mango", "Poly", "Ajax"];

Доступ к элементам
Для доступа к значению элемента массива используется синтаксис квадратных скобок массив[индекс]. Между именем переменной хранящей массив и квадратными скобками не должно быть пробела.

const clients = ["Mango", "Poly", "Ajax"];

// Указывая в скобках индекс элемента мы получаем его значение
console.log(clients[0]); // Mango
console.log(clients[1]); // Poly
console.log(clients[2]); // Ajax

Индексация элементов массива начинается с нуля.

array indices
Переопределение
В отличии от строк, элементы массива можно изменять обратившись к ним по индексу и присвоив другое значение.

const clients = ["Mango", "Poly", "Ajax"];
clients[0] = "Kiwi";
clients[1] = "Pango";
console.log(clients); // ["Kiwi", "Pango", "Ajax"]

Длина массива
Длина массива, то есть число его элементов, хранится в свойстве length. Это динамическая величина, которая изменяется автоматически при добавлении или удалении элементов.

const clients = ["Mango", "Poly", "Ajax"];
console.log(clients.length); // 3

Индекс последнего элемента
Чаще всего мы заранее в коде не знаем какая будет длина массива. Для того чтобы получить значение последнего элемента применяется следующий подход - длина массива всегда на единицу больше чем индекс последнего элемента. Используя формулу длина_массива - 1 можно получить значение последнего элемента массива произвольной длины.

const clients = ["Mango", "Poly", "Ajax"];
const lastElementIndex = clients.length - 1;
console.log(lastElementIndex); // 2
console.log(clients[lastElementIndex]); // "Ajax"

Итерация по массиву
Цикл for можно использовать для итерации по массиву, то есть «перебрать» его поэлементно.

const clients = ["Mango", "Ajax", "Poly"];

for (let i = 0; i < clients.length; i += 1) {
  console.log(clients[i]);
}

Для доступа к элементам используется синтаксис квадратных скобок массив[индекс], где индекс это значние счётчика цикла от 0 и до последнего индекса массива, то есть меньше, но не равно его длине.

Цикл for...of
Конструкция for...of объявляет цикл, перебирающий итерируемые объекты, такие как массивы и строки. Тело цикла будет выполняться для значения каждого элемента. Это хорошая замена циклу for если не нужен доступ к счётчику итерации.

for (const variable of iterable) {
  // тело цикла
}

variable — переменная которая будет хранить значение элемента на каждой итерации.
iterable — коллекция, которая имеет перечислимые элементы, например массив.
const clients = ["Mango", "Ajax", "Poly"];

for (const client of clients) {
  console.log(client);
}

const string = "javascript";

for (const character of string) {
  console.log(character);
}

Операторы break и continue
Будем искать имя клиента в массиве имен, если нашли - прервем цикл, так как нет смысла искать дальше, имена у нас уникальные.

const clients = ["Mango", "Poly", "Ajax"];
const clientNameToFind = "Poly";
let message;

for (const client of clients) {
  // На каждой итерации будем проверять совпадает ли элемент массива с
  // именем клиента. Если совпадает то мы записываем в message сообщение
  // об успехе и делаем break чтобы не искать дальше
  if (client === clientNameToFind) {
    message = "Клиент с таким именем есть в базе данных!";
    break;
  }

  // Если они не совпадают то запишем в message сообщение об отсутствии имени
  message = "Клиента с таким именем нету в базе данных!";
}

console.log(message); // "Клиент с таким именем есть в базе данных!"

Можно изначально задать message значение неудачи поиска, а в цикле перезаписать его на успех, если нашли имя. Но break все равно пригодится, так как если у нас массив из 10000 клиентов, а нужный нам стоит на позиции 2, то нет абсолютно никакого смысла перебирать оставшиеся 9998 элементов.

const clients = ["Mango", "Poly", "Ajax"];
const clientNameToFind = "Poly";
let message = "Клиента с таким именем нету в базе данных!";

for (const client of clients) {
  if (client === clientNameToFind) {
    message = "Клиент с таким именем есть в базе данных!";
    break;
  }
  // Если не совпадает, то на этой итерации ничего не делаем
}

console.log(message); // Клиент с таким именем есть в базе данных!

Используем цикл для вывода только чисел больше определенного значения.

const numbers = [1, 3, 14, 18, 4, 7, 29, 6, 34];
const threshold = 15;

// Для чисел меньше чем порог срабатывает continue, выполнение тела прекращается
// и управление передаётся на следующую итерацию.
for (let i = 0; i < numbers.length; i += 1) {
  if (numbers[i] < threshold) {
    continue;
  }

  console.log(`Число больше чем ${threshold}: ${numbers[i]}`); // 18, 29, 34
}

Присвоение по ссылке и по значению
Фундаментальным отличием сложных типов от примитивов, является то, как они хранятся и копируются. Примитивы: строки, числа, були,null и undefined, при присваивании копируются целиком, по значению (by value).

Со сложными типами всё не так. В переменной, которой присвоен массив или объект, хранится не само значение, а адрес его места в памяти, иными словами - ссылка (указатель) на него и передаются они по ссылке (by reference).

Представим переменную в виде листа бумаги. Её значение мы представим в виде записи на этом листе.

Переменная и ее значение
Если мы захотим сообщить содержимое этой записи пользователям, то можем поступить так - сделать физические копии и вручить их каждому, то есть сделать множественные независимые копии (присвоение по значению).

Присвоение по значению
Или поместить лист в закрытой комнате и дать пользователям ключ от этой комнаты, то есть один экземпляр с общим доступом (присвоение по ссылке).

Присвоение по ссылке
Теперь изменим данные на листе бумаги - значение переменной. Очевидно, что посетители комнаты всегда будут видеть изменения которые мы вносим, так как изменяется оригинал и они имеют к нему доступ. И также очевидно, что владельцы бумажных копий не заметят изменений глядя на свои копии.

Разница между присвоением по ссылке и присвоением по значению
При передаче по значению, переменным выделяется новая ячейка памяти и в нее копируются данные. Аналогия с множественными копиями бумажного листа имеет вполне реальное воплощение, отдельный лист для каждой копии.

При передаче по ссылке, вместо создания нового объекта, переменной присваивается ссылка (указатель) на уже существующий объект, то есть на его место в памяти. Таким образом, несколько переменных могут указывать на один и тот же объект, по аналогии с закрытой комнатой, у них есть ключ доступа к оригиналу листа.

Все примитивные типы присваиваются по значению, то есть создается копия.

let a = 5;
// Присвоение по значению, в памяти будет создана еще
// одна ячейка в которую будет скопировано значение 5
let b = a;
console.log(a); // 5
console.log(b); // 5

// Изменим значение a
a = 10;
console.log(a); // 10
// Значение b не изменилось так как это отдельная копия
console.log(b); // 5

Сложные типы - объекты, массивы, функции присваиваются по ссылке, то есть переменная просто получает ссылку на уже существующий объект.

const a = ["Mango"];
// Так как a это массив, в b записывается ссылка на уже существующий
// массив в памяти. Теперь a и b указывают на один и тот же массив.
const b = a;
console.log(a); // ["Mango"]
console.log(b); // ["Mango"]

// Изменим массив, добавив еще один элемент, используя указатель из a
a.push("Poly");
console.log(a); // ["Mango", "Poly"]

// b также изменилось, потому что b, как и a,
// просто содержит ссылку на одно и то же место в памяти
console.log(b); // ["Mango", "Poly"]

// Результат повторяется
b.push("Ajax");
console.log(a); // ["Mango", "Poly", "Ajax"]
console.log(b); // ["Mango", "Poly", "Ajax"]

# ========== Cравнение элементов двух массивов ==========
--------- Пересечение массивов (использование Set)
Чтобы найти intersection (пересечение) элементов двух массивов, проверим наличие каждого элемента первого массива во втором массиве. Элемент, который есть в обоих массивах, добавим в новый массив. Таким образом мы преобразуем оба массива в объекты Set. Затем с помощью метода has() проверим, есть ли каждый элемент массива nums1 в setNums2 Set Object.

let nums1 = [1, 2, 3, 4, 5]
let nums2 = [3, 4, 5, 6]

let setNums1 = new Set(nums1)
let setNums2 = new Set(nums2)

let intersections = nums1.filter((num) => 
setNums2.has(num))

console.log(intersections) // [ 3, 4, 5 ]

let setIntersections = new Set(intersections)

console.log(setIntersections) // Set { 3, 4, 5 }

------------- Различие массивов (использование Set)
Теперь найдем в массиве nums1 элементы, которых нет в setNums2 Set Object. В данном примере 1 и 2  —  это элементы, удовлетворяющие этому критерию в массиве nums1.

let nums1 = [1, 2, 3, 4, 5]
let nums2 = [3, 4, 5, 6]

let setNums1 = new Set(nums1)
let setNums2 = new Set(nums2)

let differences = nums1.filter((num) => 
!setNums2.has(num))

console.log(differences) // [ 1, 2 ]

----------- Симметричное различие массивов (использование Set)
Теперь найдем в массивах nums1 и nums2 уникальные элементы  —  те, которые не находятся в обоих массивах одновременно.

let nums1 = [1, 2, 3, 4, 5]
let nums2 = [3, 4, 5, 6]

let setNums1 = new Set(nums1)
let setNums2 = new Set(nums2)

let symmetrics = nums1
   .filter((num) => {
     return !setNums2.has(num)
 })
 .concat(
   nums2.filter((num) => {
     return !setNums1.has(num)
   })
 )

console.log(symmetrics) // [ 1, 2, 6 ]

-------------- Пересечение массивов (использование функций высшего порядка)
Чтобы найти пересекающиеся элементы двух массивов, нужно посмотреть, есть ли каждый элемент первого массива во втором массиве. Если он есть во втором массиве, то это значение должно быть возвращено в новый массив. В этом случае можно использовать методы filter и includes в JavaScript.

let arr1 = [“a”, “b”, “e”, “f”]
let arr2 = [“a”, “b”, “c”, “d”]

let intersection = arr1.filter((item) => 
arr2.includes(item))

console.log(intersection) // [ ‘a’, ‘b’ ]

--------------- Различие массивов (использование функций высшего порядка)
В отличие от описанной выше ситуации, теперь все должно быть в точности наоборот. Каждый элемент первого массива не должен находиться во втором массиве. В данном примере “e” и “f” являются элементами, находящимися только в массиве arr1.

let arr1 = [“a”, “b”, “e”, “f”]
let arr2 = [“a”, “b”, “c”, “d”]

let difference = arr1.filter((item) => 
!arr2.includes(item))

console.log(difference) // [ ‘e’, ‘f’ ]
Так же находим элементы, находящиеся только во втором массиве.

let arr1 = [‘a’, ‘b’, ‘e’, ‘f’]
let arr2 = [‘a’, ‘b’, ‘c’, ‘d’]

let difference = arr2.filter((item) => 
!arr1.includes(item))

console.log(difference) // [ ‘c’, ‘d’ ]

----------- Симметричное различие массивов (использование функций высшего порядка)
Все элементы, кроме элементов пересечения массивов, являются симметрично различными элементами. В данном случае это элементы “e” и “f” из первого массива и “c” и “d” из второго массива. Чтобы добавить эти элементы в массив, воспользуемся методом concat.

let symetric = arr2
  .filter((item) => {
     return !arr1.includes(item)
 })
 .concat(
   arr1.filter((item) => {
     return !arr2.includes(item)
   })
 )

console.log(symetric) // [ ‘c’, ‘d’, ‘e’, ‘f’ ]