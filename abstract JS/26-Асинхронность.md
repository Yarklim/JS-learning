Асинхронность
Весь код выполняется процессором вашего компьютера. Код который мы писали до сих пор был синхронным, то есть занимал процессор на все время своего выполнения. Например, скорость выполнения цикла для итерации по массиву зависит от скорости процессора.

Есть операции которые взаимодействуют с внешним миром. Например, обмен данными с сервером по сети, что намного медленнее, чем получение их из памяти. Если такие операции обрабатываются синхронно, то процессор простаивает пока идет сетевой запрос на сервер, вместо того чтобы выполнять другой код.

Синхронный код выполняется последовательно, каждая инструкция ожидает пока выполнится предыдущая. Когда вы вызываете функцию, которая выполняет длительное действие, это останавливает программу на всё время её выполнения. То есть в модели синхронного программирования все происходит по очереди.

ИНТЕРЕСНО
Представьте очередь покупки билетов на поезд. Вы не можете начать покупать билет до тех пор, пока не купит человек перед вами. Точно так же люди, стоящие за вами, не могут начать покупать билеты до тех пор, пока не купите вы.

В асинхронном коде одновременно могут выполняться несколько операций. В такой модели сетевой запрос на сервер не остановит программу, она продолжит выполнять другие операции. Когда запрос завершится, программа информируется об этом и получает доступ к результату (например, данным от сервера).

ИНТЕРЕСНО
Представьте обед в ресторане. Вы и другие посетители, заказываете еду. Вам не нужно ждать, пока им принесут еду, прежде чем заказывать. Точно так же другие посетители не должны ждать, пока вы получите свое блюдо и поедите, прежде чем они смогут заказать. Каждый получит свое блюдо, как только его закончат готовить.

Рассмотрим разницу на примере в котором программа выполняет два сетевых запроса на сервер, после чего обрабатывает их результат. Операции 1 и 2 это функции которые делают запросы на севрер, а 3, 4 и 5 любой другой привычный вам код.

sync vs async code
В синхронной модели все понятно и довольно печально - предыдущие операции блокируют выолнение последующих пока не закончатся. Если операции 3-5 это обработка кликов пользователя, то интерфейс просто зависнет пока не выполнятся и обработаются результаты запросов 1-2.

Например, пользователь отправил комментарий (сетевой запрос) и в тоже время захотел открыть сайдбар с последними новостями. После клика отправить комментрий, интерфейс зависнет и не будет реагировать на его действия пока от сервера не придет результат отправки комментария. Согласитесь, это не очень удобно.

В асинхронной модели старт сетевого запроса вызывает как бы разветвление, то есть запуск запроса и результат его обработки это различные действия. Пока выполяется запрос, программа продолжает работать и выполнять другой код. Как только сетевой запрос выполнен, программа может начать обрабатывать его результат как только будет свободна. Это значит, что пользователь отправил комментарий и сразу смог открыть сайдбар со свежими новостями, не дожидаясь пока придёт ответ от сервера.

То есть в единицу времени все также может выполняться только одна операция, потому что JavaScript однопоточный. Асинхронное программирование достигается путем отложенных вызовов функций, где инициализация асинхронной операции и обработка её результата это разные действия.

Асинхронный код
В синхронном коде следующая инструкция не может начать свое выполнение пока не выполнится предыдущая. То есть инструкции обрабатываются последовательно.

console.log("First log");
console.log("Second log");
console.log("Third log");

Следующий код - асинхронный. С функцией setTimeout() мы познакомимся дальше. Сейчас о ней нам нужно знать только то, что она принимает два параметра: callback-функцию, которая будет вызвана по истечении времени, которое мы передаем вторым аргументом.

// Will run first
console.log("First log");

setTimeout(() => {
  // Will run last, after 2000 milliseconds
  console.log("Second log");
}, 2000);

// Will run second
console.log("Third log");

Функция setTimeout() отрабатывает синхронно и регистрирует отложенный вызов переданной callback-функции, которая будет вызвана асинхронно, через указанный промежуток времени.

Многопоточность
Не путайте асинхронность и многопоточность (параллелизм) - это разные модели программирования. Приведем простую аналогию, которая все расставит по своим местам. Представьте, что вы шеф в ресторане и приходит заказ на кофе и тосты.

Синхронный однопоточный подход - вы сами сначала готовите кофе, затем тосты и подаёте их, после чего убираете на кухне.
Асинхронный однопоточный подход - вы начинаете готовить кофе и устанавливаете таймер, затем начинаете готовить тосты и так же устанавливаете таймер. Пока кофе и тосты готовятся, вы убираете на кухне. Когда таймеры срабатывают, вы снимаете с огня кофе, достаете тосты и подаёте их.
Многопоточный подход (параллелизм) - вы нанимаете двух помошников, одного для приготовления кофе, а другого для тостов. Теперь у вас есть проблема управления помошниками (потоками), чтобы они не конфликтовали друг с другом на кухне при совместном использовании ресурсов.
В асинхронных однопоточных процессах у вас есть график задач, где некоторые задачи зависят от результата работы других. По мере выполнения каждой задачи вызывается код для обработки её результата. Но вам нужен только один работник для выполнения всех задач, а не один работник на задачу.

Таймеры
Внутренний таймер-планировщик браузера позволяет откладывать вызов функции на определенный период времени. Для этого есть тайм-ауты и интервалы, которые контролируют когда и как часто вызывается функция. Таймеры реализованы в браузере, а не встроенны в язык, и доступны на глобальном объекте window.

Таймаут
Метод setTimeout() позволяет запланировать запуск функции через определённое время.

const timerId = setTimeout(callback, delay, arg1, arg2, ...);

callback - функция, выполнение которое необходимо запланировать.
delay - время в миллисекундах, через которое callback-функция будет вызвана один раз.
Дополнительные аргументы (arg1, arg2 и т. д.) будут переданы callback-функции во время вызова. Возвращает цифровой идентификатор созданного таймера, который используется для его удаления. .


Если нам, по какой-то причине, нужно отменить вызов функции внутри таймаута, используется метод clearTimeout(id), которая принимает идентификатор таймера и очищает (удаляет) его.

const greet = () => {
  console.log("Hello!");
};

const timerId = setTimeout(greet, 3000);

clearTimeout(timerId);

Поскольку мы вызвали clearTimeout(), который исполнится раньше чем будет вызвана функция greet(), таймер с timerId будет удалён и регистрация отложенного вызова greet() отменится. Поэтому в консоль ничего не выведется.

Интервал
Метод setInterval() - это простой способ повторения кода снова и снова с установленным промежутком времени повторений. Синтаксис и параметры такие же как у setTimeout(). В отличие от setTimeout(), интервал запускает выполнение функции не один раз, а регулярно повторяет её через указанный промежуток времени. Остановить исполнение можно вызовом метода clearInterval(id).

const timerId = setInterval(callback, delay, arg1, arg2, ...);

При клике на кнопку «Start» запустим интервал и будем каждую секунду выводить в консоль строку. Используем Math.random() чтобы строки были разные. По клику на кнопку «Stop» вызовем clearInterval() и передадим идентификатор интервала который надо остановить.


Частота срабатывания счетчика
У браузерного таймера есть минимальная возможная задержка. В современных браузерах она колеблется примерно от 0 до 4 миллисекунд. В более старых браузерах задержка может быть больше и достигать 15 миллисекунд. По стандарту, минимальная задержка составляет 4 миллисекунды, так что разницы между setTimeout(callback, 1) и setTimeout(callback, 4) нет.

Таймер может срабатывать реже чем указано в параметре delay, потому что при слишком большой загрузке процессора некоторые запуски функций-интервалов будут пропущены. Браузеры продолжают выполнять таймауты и интервалы даже если вкладка браузера неактивна, но при этом снижают частоту срабатывания таймеров.

Дата и время
Класс Date абстрагирует большую часть работы с датами напрямую. Это позволяет нам представлять моменты во времени как объекты и манипулировать ими заранее определёнными методами. Используя возможности класса Date можно создавать часы, счетчики, календари и другие интерактивные элементы интефрейса.

Создание даты
Экземпляр объекта Date это объект представляющий определённый момент времени. Создание даты без аргументов, возвращает объект хранящий дату и время на момент его инициализации, то есть текущие. В строчном преобразовании объект возвращает результат вызова метода toString(), поэтому в первом логе мы получим строку, а не объект.

const date = new Date();

console.log(date);
// "Fri Jun 18 2021 15:01:35 GMT+0300 (Eastern European Summer Time)"

console.log(date.toString());
// "Fri Jun 18 2021 15:01:35 GMT+0300 (Eastern European Summer Time)"

Unix время
Внутренне даты представлены в миллисекундах прошедших с полночи 1 января 1970 года в часовом поясе UTC. Для компьютера это дата начала отсчета всего времени - Unix время. Поэтому при инициализации даты одним числом, оно представляет собой количество прошедших миллисекунд.

console.log(new Date(0));
// "Thu Jan 01 1970 03:00:00 GMT+0300 (Eastern European Standard Time)"

console.log(new Date(15000));
// "Thu Jan 01 1970 03:00:15 GMT+0300 (Eastern European Standard Time)"

Метод getTime() возвращает числовое представление даты (timestamp) - количество миллисекунд прошедших с полночи 1 января 1970 года.

const date = new Date();
console.log(date.getTime()); // 1624021654154

Удобство этого формата заключается в том, что можно представлять точные моменты времени в виде одного числа и не беспокоиться о датах, строках и часовых поясах, так как можно получить всю необходимую информацию когда необходимо.

Установка даты
При создании экземпляра класса Date, можно установить дату строкой или числами. Строка может описывать только дату или дату и время.

const teamMeetingDate = new Date("March 16, 2030");
console.log(teamMeetingDate);
// "Mon Mar 16 2030 00:00:00 GMT+0200 (Eastern European Standard Time)"

const preciseTeamMeetingDate = new Date("March 16, 2030 14:25:00");
console.log(preciseTeamMeetingDate);
// "Mon Mar 16 2030 14:25:00 GMT+0200 (Eastern European Standard Time)"

Установка времени в виде строк внутренне вызывает метод Date.parse(), который преобразует строку в число - количество миллисекунд. Именно поэтому формат передаваемой строки очень гибкий. Например, можно не указывать ноль для дней и месяца. Рассмотрим несколько примеров, которые приведут к одинаковому результату.

new Date("2030-03-16");
new Date("2030-03");
new Date("2030");
new Date("03/16/2030");
new Date("2030/03/16");
new Date("2030/3/16");
new Date("March 16, 2030");
new Date("March 16, 2030 14:25:00");
new Date("2030-03-16 14:25:00");
new Date("2030-03-16T14:25:00");
new Date("16 March 2030");

Другой способ создания новых объектов - это передать семь чисел, которые описывают год, месяц (начинается с 0), день, часы, минуты, секунды и миллисекунды. Обязательны только первые три.

const date = new Date(2030, 2, 16, 14, 25, 0, 0);
console.log(date);
// Sat Mar 16 2030 14:25:00 GMT+0200 (Eastern European Standard Time)

Методы
Экземпляр класса Date имеет множество методов для чтения и записи значений даты и времени. Методы возвращают или присваивают год, месяц, день месяца или недели, час, минуту, секунду и миллисекунду для каждого экземпляра. Эти данные могут быть представлены в виде строки с учетом местного календаря или языка.

Геттеры
Геттеры используются для чтения всей даты или отдельной составляющей. Возвращаемое значение зависит от текущего часового пояса установленного на вашем компьютере.

const date = new Date();
console.log("Date: ", date);

// Возвращает день месяца от 1 до 31
console.log("getDate(): ", date.getDate());

// Возвращает день недели от 0 до 6
console.log("getDay(): ", date.getDay());

// Возвращает месяц от 0 до 11
console.log("getMonth(): ", date.getMonth());

// Возвращает год из 4 цифр
console.log("getFullYear(): ", date.getFullYear());

// Возвращает час
console.log("getHours(): ", date.getHours());

// Возвращает минуты
console.log("getMinutes(): ", date.getMinutes());

// Возвращает секунды
console.log("getSeconds(): ", date.getSeconds());

// Возвращает миллисекунды
console.log("getMilliseconds(): ", date.getMilliseconds());

Существуют эквивалентные версии этих методов, которые возвращают значения в формате UTC (Coordinated Universal Time), а не адаптированные к текущему часовому поясу пользователя.

const date = new Date();
console.log("Date: ", date);

// Возвращает день месяца от 1 до 31
console.log("getUTCDate(): ", date.getUTCDate());

// Возвращает день недели от 0 до 6
console.log("getUTCDay(): ", date.getUTCDay());

// Возвращает месяц от 0 до 11
console.log("getUTCMonth(): ", date.getUTCMonth());

// Возвращает год из 4 цифр
console.log("getUTCFullYear(): ", date.getUTCFullYear());

// Возвращает час
console.log("getUTCHours(): ", date.getUTCHours());

// Возвращает минуты
console.log("getUTCMinutes(): ", date.getUTCMinutes());

// Возвращает секунды
console.log("getUTCSeconds(): ", date.getUTCSeconds());

// Возвращает миллисекунды
console.log("getUTCMilliseconds(): ", date.getUTCMilliseconds());

Сеттеры
Все, что можно прочитать можно записать, методы для записи называются также как геттеры, но начинаются с приставки set. Также для всех методов есть их UTC эквивалент.

const date = new Date("March 16, 2030 14:25:00");

date.setMinutes(50);
// "Sat Mar 16 2030 14:50:00 GMT+0200"

date.setFullYear(2040, 4, 8);
// "Tue May 08 2040 14:50:00 GMT+0300"

Форматирование даты
Объект даты может быть представлен в разных строчных и числовых форматах. Для этого существует целый набор методов. Например, toString(), toDateString() и toTimeString() возвращают стандартное строчное представление, не заданное жёстко в стандарте, а зависящее от браузера. Единственное требование к нему - читаемость человеком. Метод toString() возвращает дату целиком, а toDateString() и toTimeString() - только дату и время соответственно.

const date = new Date("March 16, 2030 14:25:00");

date.toString();
// "Sat Mar 16 2030 14:25:00 GMT+0200 (Eastern European Standard Time)"

date.toTimeString();
// "14:25:00 GMT+0200 (Eastern European Standard Time)"

date.toLocaleTimeString();
// "2:25:00 PM"

date.toUTCString();
// "Sat, 16 Mar 2030 12:25:00 GMT"

date.toDateString();
// "Sat Mar 16 2030"

date.toISOString();
// "2030-03-16T12:25:00.000Z"

date.toLocaleString();
// "3/16/2030, 2:25:00 PM"

date.getTime();
// 1899894300000