Простой http сервер
Сегодня Node.js используется во многих областях, но его первоначальная цель была в предоставлении услуг веб-сервера.

По сравнению с настройкой сервера Apache, NGINX или любого другого веб-сервера, настройка веб-сервера в Node очень проста. Встроенный модуль http (и его аналог модуль https для защищенного соединения) предоставляет метод createServer, который создает простой веб-сервер.

ПРИМЕЧАНИЕ
Но стоит отметить, что NGINX это reverse proxy сервер и он обычно используется вместе с Node.js приложением, а не как его альтернатива

Все, что необходимо сделать — это указать функцию обратного вызова, которая будет обрабатывать входящие запросы. Запускается сервер вызовом метода listen и указанием номер порта, на котором сервер будет ожидать запросы к себе:

const http = require('docs/additional_materials/simple-web-server/http');
const port = 3000;

const server = http.createServer((req, res) => {
  res.end('Hello world!');
});

server.listen(port, () => {
  console.log(`Сервер ожидает соединения на порте: ${port}`);
});

Из соображений безопасности и отладки обычно используются порты выше 1024 и выбирают такие номера, как 3000, 8000, 3030 и 8080, поскольку их легче запомнить Если вы сохраните этот код в файл server.js и запустите скрипт в консоли

node server.js

то вбив в адресной строке браузера адрес http://localhost:3000/, вы увидите строку 'Hello world!' . Остановить выполнение скрипта можно комбинацией Ctrl+C в терминале

Как видим в основе веб-сервера Node лежит функция обратного вызова и именно она обрабатывает все входящие запросы. Ей передается два аргумента: объект IncomingMessage - переменная req и объект ServerResponse - переменная res. Объект IncomingMessage содержит всю информацию о НТТР-запросе: какой URL затребован, все посланные заголовки, все посланные в теле данные и т.д. Объект ServerResponse содержит свойства и методы для управления ответом, который отсылается назад клиенту (обычно браузеру). Объект ServerResponse реализует интерфейс потока записи, определяющий то, как именно данные пересылаются клиенту.

Web сервер на Node.js
Теперь мы создадим простейший web сервер, для отображения статичного сайта. Структура сайта будет следующей:


Рис. 3 - структура статичного веб-сайта
Файл index.html содержит следующую разметку:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="/css/main.css" />
    <title>Simple site</title>
  </head>
  <body>
    <h3>Пример простого сайта</h3>
    <img
      src="/img/photo.jpg"
      alt="photo of turned on laptop computer"
      class="picture"
    />
    <div class="js-class"></div>
    <script src="/js/main.js"></script>
  </body>
</html>

В нем мы подключаем стили из файла main.css и javascript код из файла main.js. Также у нас в html отображается картинка. Это сделано для того, чтобы наш сервер отдавал любой файл, который запросит у него браузер, стили, код или изображения. Чтобы проверить, что main.js подключился правильно мы выводим соответствующее сообщение в index.html

const container = document.querySelector('.js-class');
container.textContent = 'javaScript подключен на странице';

Создадим файл server.js и поместим в него следующий код, чтобы наш сайт правильно отображался при запуске:

const http = require('docs/additional_materials/simple-web-server/http');
const fs = require('fs').promises;
const url = require('url');
const path = require('path');

const contentType = {
  '.html': 'text/html',
  '.js': 'text/javascript',
  '.css': 'text/css',
  '.jpg': 'image/jpeg',
  '.ico': 'image/x-icon',
};

http
        .createServer(async (req, res) => {
          const { pathname } = url.parse(req.url);
          let filename = pathname.substring(1);
          if (pathname === '/') {
            filename = 'index.html';
          }
          const type = contentType[path.extname(filename)];
          res.writeHead(200, { 'Content-Type': type });
          if (type.includes('image')) {
            const img = await fs.readFile(filename);
            res.write(img, 'hex');
          } else {
            const content = await fs.readFile(filename, 'utf8');
            res.write(content);
          }
          res.end();
        })
        .listen(3000, () => console.log('Listen server on port 3000'));

Выполним наш код следующей командой:

$ node server.js

После выполнения мы увидим сообщение - Listen server on port 3000 Это значит, что сервер запущен и готов к работе. Откроем браузер и перейдем по адресу http://localhost:3000/ мы увидим следующее окно

alt text

Рис. 4 - реализация простого http сервера

Мы видим, что заголовок синего цвета, а значит стили подключились, также видим сообщение из main.js. Давайте подробнее разберем, код и что здесь происходит. Вначале мы подключаем модули, которые необходимы нам для работы. Дальше мы видим объект с MIME типами, который позволит нам отдавать разнообразный контент: Что это значит? Заголовок-сущность Content-Type при ответе браузеру используется для того, чтобы определить MIME тип ресурса. В ответах сервера заголовок Content-Type сообщает клиенту, какой будет тип передаваемого контента. В некоторых случаях браузеры пытаются сами определить MIME тип передаваемого контента, но их реакция может быть неадекватной. Поэтому когда мы будем отдавать файл клиенту, мы зная, расширение файла, можем подставлять соответствующий MIME тип в заголовок Content-Type

const contentType = {
  '.html': 'text/html',
  '.js': 'text/javascript',
  '.css': 'text/css',
  '.jpg': 'image/jpeg',
  '.ico': 'image/x-icon',
};

Модуль path, который отвечает за различные операции с путями файлов. Так как в GET запросах параметры передаются через url, для их обработки мы должны проанализировать эту строку. Это удобно сделать с помощью стандартного модуля url и его функции parse

const { pathname } = url.parse(req.url);

Дальше находим имя файла который запросил клиент через HTTP-запрос

let filename = pathname.substring(1);

Здесь мы отбрасываем знак ‘/’ с которого начинается путь к файлу. Единственным исключением является обращение к корню сайта и тогда необходимо отдавать файл index.html

if (pathname === '/') {
  filename = 'index.html';
}

Определяем расширение файла, на который поступил запрос от клиента и выбираем необходимый MIME тип в переменную type. И устанавливаем заголовок ответа Content-Type

const type = contentType[path.extname(filename)];
res.writeHead(200, { 'Content-Type': type });

Поскольку отдача изображений и текстовых файлов отличается, мы проверяем, не пришел ли запрос на картинку от клиента. И так как изображение - это двоичные файлы, то мы считываем файл и передаем считанный буфер в метод write, где вторым параметром устанавливаем кодировку 'hex'.

if (type.includes('image')) {
  const img = await fs.readFile(filename);
  res.write(img, 'hex');
} else {
  const content = await fs.readFile(filename, 'utf8');
  res.write(content);
}
res.end();

Если же это текстовый файл, то при считывании файла указываем кодировку utf8. Заканчиваем ответ на запрос командой res.end()


Нами рассмотрен минимально возможный веб-сервер. Но для обслуживания веб-сайтов используют фреймворки, такие как Express, которые берут на себя работу по построению веб-сервера с нуля.

Статические ресурсы
Но давайте вернемся к нашему веб-серверу. У нас есть пример статического сайта для которого мы написали простой веб-сервер на чистой Node.js. Рассмотрим, как в Express можно отправлять пользователю статические файлы. Для представления статических файлов, в Express используется функция промежуточной обработки express.static.

Для того чтобы начать непосредственное предоставление файлов, необходимо передать имя каталога, в котором находятся статические ресурсы, в функцию промежуточной обработки express.static.

Создадим для статических файлов в проекте каталог public, в который добавим наш сайт c index.html страницей,

Главный файл нашего приложения app.js будет выглядеть следующим образом:

const express = require('express');
const path = require('path');
const app = express();

app.use(express.static(path.join(__dirname, 'public')));

app.listen(3000, () => {
  console.log('Example app listening on port 3000!');
});

И если сейчас мы запустим наш сервер, то по адресу http://localhost:3000/ мы увидим то, что показано на рисунке 4 из предыдущей статьи "Web сервер на Node.js". Express полностью взял на себя отображение нашего сайта.

Чтобы вставить компонент express.static в процесс обработки запроса, вызывается функция app.use(). Эта функция express позволяет добавлять различные компоненты, они еще называются middleware или промежуточное ПО, в конвейер обработки запроса:

app.use(express.static(path.join(__dirname + '/public')));

Причем данный вызов должен располагаться до всех остальных вызовов функции app.get(), app.post() и т.д. В первую очередь мы обрабатываем статические ресурсы. В саму функцию express.static() передается путь к папке со статическими файлами. Специальная переменная Node.js __dirname позволяет получить полный путь к папке.

