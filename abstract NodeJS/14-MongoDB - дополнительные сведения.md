Работа с массивами
Оператор $in определяет массив возможных выражений и ищет те ключи, значение которых имеется в массиве:

db.cats.find({ age: { $in: [2, 10] } });

Результат:

{
    "_id" : ObjectId("5f8382425ba83a4f1829ca5c"),
    "name" : "Lama",
    "age" : 2.0,
    "features" : [
        "ходит в лоток",
        "не дает себя гладить",
        "серый"
    ]
}

{
    "_id" : ObjectId("5f838b225ba83a4f1829ca60"),
    "name" : "Dariy",
    "age" : 10.0,
    "features" : [
        "ходит в лоток",
        "не дает себя гладить",
        "серый"
    ],
    "owners" : {
        "name" : "Nata",
        "age" : 23.0,
        "address" : "Poltava"
    }
}

Противоположным образом действует оператор $nin - он определяет массив возможных выражений и ищет те ключи, значение которых отсутствует в этом массиве

db.cats.find({ age: { $nin: [2, 10] } });

Оператор $all похож на $in: он также определяет массив возможных выражений, но требует, чтобы документы имели весь определяемый набор выражений.

db.cats.find({ features: { $all: ['ходит в лоток', 'дает себя гладить'] } });

Результат:

{
    "_id" : ObjectId("5f8382425ba83a4f1829ca5d"),
    "name" : "Liza",
    "age" : 4.0,
    "features" : [
        "ходит в лоток",
        "дает себя гладить",
        "белый"
    ]
}

{
    "_id" : ObjectId("5f8383025ba83a4f1829ca5f"),
    "name" : "Murzik",
    "age" : 1.0,
    "features" : [
        "ходит в лоток",
        "дает себя гладить",
        "черный"
    ]
}

Оператор $size используется для нахождения документов, в которых массивы имеют число элементов, равным значению $size.

db.cats.find({ features: { $size: 3 } });

Оператор $push добавляет значения в массив

db.cats.updateOne({ name: 'Tom' }, { $push: { features: 'вонюч' } });

Если необходимо добавить сразу несколько значений

db.cats.updateOne(
  { name: 'Tom' },
  { $push: { features: { $each: ['храпит', 'злой'] } } },
);

Оператор $addToSet подобно оператору $push добавляет объекты в массив. Отличие состоит в том, что $addToSet добавляет данные, если их еще нет в массиве:

db.cats.update({ name: 'Lama' }, { $addToSet: { features: 'безумен' } });

Оператор $pop позволяет удалять элемент из массива:

db.cats.update({ name: 'Tom' }, { $pop: { features: 1 } });

1 конец массива -1 начало массива

Оператор $pull удаляет по значению

db.cats.update({ name: 'Tom' }, { $pull: { features: 'серый' } });

А если мы хотим удалить не одно значение, а сразу несколько, тогда мы можем применить оператор $pullAll:

db.cats.update(
  { name: 'Tom' },
  { $pullAll: { features: ['не дает себя гладить', 'вонюч', 'храпит'] } },
);

Драйвер MongoDB
Драйвер MongoDB
Драйвер MongoDB Node.js позволяет взаимодействовать с базами данных MongoDB из приложений Node.js. Драйвер понадобится нам для подключения к базе данных и выполнения запросов. Если у вас не установлен драйвер MongoDB Node.js, вы можете установить его в проект с помощью следующей команды.

npm install mongodb

Модуль MongoDB экспортирует MongoClient, он используется для подключения к базе данных MongoDB, выполнения операций и закрытия соединения с этим кластером. Так же мы экспортируем ObjectId он понадобится нам, чтобы преобразовать строку к объекту _id MongoDB

const { MongoClient, ObjectId } = require('mongodb');

Первое, что нам нужно сделать это поместить константу URI подключения в переменную окружения DB_HOST. URI подключение - это строка подключения, которую вы скопировали из Atlas в предыдущем разделе. Поместим ее в файл .env

DB_HOST=mongodb+srv://<username>:<password>@<your-cluster-url>/test?retryWrites=true&w=majority

В самой программе получим доступ к URI

require('dotenv').config();
const uriDb = process.env.DB_HOST;

Теперь, когда у нас есть URI, мы можем создать экземпляр MongoClient.

const client = await new MongoClient(uriDb, {
  useUnifiedTopology: true,
}).connect();

Использовать экземпляр MongoClient для подключения к нашему кластеру можно после выполнения connect(). Функция вернет нам обещание и мы ставим await, чтобы дождаться экземпляр подключения. После этого мы готовы взаимодействовать с нашей базой данных.

Вызовы функций, которые взаимодействуют с базой данных, мы поместим в операторы try/catch, чтобы обрабатывать любые неожиданные ошибки.

try {
  // работа с базой данных
} catch (e) {
  console.error(e);
}

В конце мы закрываем подключение к нашей базе, поэтому заканчиваем try/catch оператором finally.

finally {
  await client.close();
}

REST API
Перепишем на приложение из раздела REST API с использованием базы данных MongoDB. Полный код приложения:


Модификации подвергся файл роутинга api/index.js. Рассмотрим более подробно изменения и начнем с обработчика роутинга /tasks

router.get('/tasks', async (req, res, next) => {
  const client = await new MongoClient(uriDb, {
    useUnifiedTopology: true,
  }).connect();
  try {
    const results = await client.db().collection('todos').find().toArray();
    res.json({
      status: 'success',
      code: 200,
      data: {
        tasks: results,
      },
    });
  } catch (e) {
    console.error(e);
    next(e);
  } finally {
    await client.close();
  }
});

Мы создаем экземпляр подключения в базе данных MongoDB. Всю логику взаимодействия мы помещаем в оператор try/catch. Находим все возможные задачи

const results = await client.db().collection('todos').find().toArray();

Здесь необходимо обратить внимание, что оператор find возвращает нам курсор, и необходимо преобразовать его в массив методом toArray. После мы отправляем, как и прежде, результат в виде JSON.

В принципе работа остальных обработчиков в целом похожа и они имеют общую схему с некоторыми отличиями.

При получении задачи по id, мы преобразуем строку id в объект ObjectId

const objectId = new ObjectId(id);

После выполняем деструктуризацию единственного объекта задачи

const [result] = await client
  .db()
  .collection('todos')
  .find({ _id: objectId })
  .toArray();

И в переменной result будет лежать искомый объект примерно такого вида

{
  "_id": "5f8644b9cf20df3314f5b7b7",
  "title": "My work",
  "text": "The best",
  "isDone": false
}

Создание новой задачи мы выполняем следующей командой. Роут ожидает объект вида

{
  "title": "My work",
  "text": "The best"
}

А сохранение в базе происходит через функцию insertOne

const result = await client
  .db()
  .collection('todos')
  .insertOne({ title, text, isDone: false });

Мы вставляем новый документ в базу и результатом будет объект содержащий:

{
  "acknowledged": true,
  "insertedId": "61264cb97361c8156dbf793c"
}

Свойство insertedId содержит ObjectId с вставленным документом. Отправляем JSON c полученным результатом.

res.status(201).json({
  status: 'success',
  code: 201,
  data: { task: result },
});

Обновления PUT и PATCH почти идентичны

const { value: result } = await client
  .db()
  .collection('todos')
  .findOneAndUpdate(
    { _id: objectId },
    { $set: { title, text } },
    { returnDocument: 'after' },
  );

Результат операции объект со свойством value, куда драйвер поместит обновленный документ. Первым параметром для функции findOneAndUpdate мы указываем критерий поиска { _id: objectId }. Второй параметр это объект обновления { $set: { title, text } }, где мы используем модификатор $set, чтобы произошло обновление только указанных полей, а не полная замена документа на эти поля. Третий параметр { returnDocument: 'after' } говорит о том, что мы хотим получить не исходный документ, а уже обновленный.

Удаление производим с помощью функции findOneAndDelete:

const { value: result } = await client
  .db()Аутентификация и авторизация - другие варианты
  .collection('todos')
  .findOneAndDelete({ _id: objectId });

Здесь мы поступили немного по другому. В предыдущий раз мы возвращали статус 204, в этот 200 и удаленный документ.

ЗАМЕЧАНИЕ
Необходимо отметить, что это упрощенный учебный пример. Он показывает подключение к базе MongoDB и выполнение простейших запросов. Например всю логику работы мы поместили в роуты, но "правильно" было бы работу с базой вынести в отдельный, сервис, а логику работы обработчиков перенести в контроллеры. Также мы не обрабатываем ошибки отсутствия искомых документов в базе и не возвращаем при этом ошибку 404 (Not found). Эти вещи были специально опущены, чтобы показать именно работу с драйвером MongoDB, но в дальнейшем при рассмотрении ODM Mongoose мы построим наше приложение более "правильно".

API доступно по URL: https://nodebook-api-mongodb.glitch.me/api/tasks/.

И вы опять можете с помощью Postman выполнить все CRUD операции