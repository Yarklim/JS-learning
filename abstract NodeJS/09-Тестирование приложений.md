Введение в тестирование
Большое приложение это всегда высокая вероятность появления ошибок. Без тестирования приложение часто проверяют вручную, а если приложение старое и с большим функционалом то иногда оно выглядит как черный ящик. Здесь на помощь нам приходит автоматизированное тестирование функциональности приложения. Тестирование это когда мы пишем код который автоматически проверяет, не появились ли ошибки при внесении изменений в наше приложение.

В принципе программисты пишут чаще всего модульное тестирование. Модульное тестирование выполняет проверку логики приложения на уровне функции или метода; Модульное тестирование применяется ко всем видам приложений.

По подходу написания тесты делятся на два типа.

Code first. Вначале выполняется разработка, а затем тестирование. То есть сначала происходит написание кода, реализуется функциональность нашего приложение, а затем мы пишем тест на реализованную функциональность и тут уже или дорабатываем функциональность или переходим к следующей задаче разработки
Test first. Это другой подход. Еще до написания функциональности нашего приложения пишется тест, на будущую функциональность. И только после реализации тестов мы переходим к написанию функциональности нашего приложения.
Методологически тесты делят на два вида

TDD - разработка через тестирование (Test-Driven Development)
BDD - разработка через реализацию поведения (Behavior-Driven Development).
Как в подходах TDD, так и в BDD, тесты пишутся заранее до написания фактического кода. Написание тестов в первую очередь помогает спрогнозировать ход разработки, что в конечном итоге предотвращает пропуск каких-либо моментов в функциональности работы приложения. Как видно из схемы, BDD работает поверх TDD.

TDD vs BDD

Алгоритм написания тестов TDD следующий. Сначала происходит написание нескольких тестов. Затем выполняется запуск тестов и поскольку функциональность еще не реализована они терпят неудачу. Мы приступаем к реализации необходимой функциональности приложения, и постепенно тесты начинают проходить, до полной реализации функциональности.

Алгоритм написания тестов в BDD почти одинаков, но есть стилистическое различие. BDD — описывает поведение разработки программного обеспечения, фактически мы делаем план перед написанием кода. Тесты пишутся, с учетом что мы ожидаем от работы еще не реализованной функциональности. Подход создан для того, чтобы исправить проблемы, которые могут возникнуть при использовании ТDD, а именно облегчить поддержку кода через наглядное представление о его функциональности, тесты и их результаты выглядят более понятно не только для программистов, но и для заказчика.

Важным в пониманием тестирования является тестовая пирамида. Пирамида тестирования используется для распределения тестов по уровням приложения.

piramida

Каждое приложение можно разделить на несколько слоев. Рассмотрим типичное расслоение с уровнем компонентов, сервисами и пользовательским интерфейсом. Нижняя часть пирамиды покрыта модульными (unit) тестами. Они написаны в основном разработчиками и охватывают атомарные компоненты, такие как классы, методы и функции. Запускаются очень часто, работаю быстро и их количество в рамках приложения велико.

Интеграционные тесты. Это проверка, не сломала ли новый реализованный функционал код приложения. Это сценарии, которые охватывают более сложные функции, такие как тесты API. Редко запускаются в основном при релизах и мерджах веток.

В верхней части находятся тесты пользовательского интерфейса и ручного тестирования. Их мы рассматривать не будем, запускаются они редко и работают медленно.

Библиотеки для тестирования
Библиотеки для тестирования — это специальные инструменты, помогающие в процессе тестирования. Конечно можно написать собственную библиотеку запуска своих тестов, но на данный сообщество уже выполнило огромный объем работы и разработало огромное количество инструментов для тестирования, поэтому проще будет использовать их.

Технологический стек для модульного тестирования
stack

Runner, Reporter
Необходимы, чтобы исполнить тесты. Модульный тест это обычный JavaScript файл, но чтобы воспользоваться добавленными функциями исполнителей тестов, например запускать несколько тестов за раз, сообщать об ошибках или успешном завершении нам необходим исполнитель тестов. Мы будете использовать Jest, но есть альтернативы Mocha и Jasmine или Ava.

SPY, Mock
При написании тестов мы избегаем их связывания с другими частями инфраструктуры нашего приложения. Таким образом другие не тестируемые функции, должны быть заменены «поддельной» функцией, которая ведет себя так, как от нее ожидают, и тут нам на помощь придут стабы (stubs) и моки (mock) Разница в терминах в том, что стаб ничего не проверяет, а лишь имитирует заданное состояние, а мок – это объект, у которого есть ожидания. Например, что тестируемая функция должна быть вызвана определенное число раз. Для тестирования stubs и mock мы используем Jest, но и есть другие библиотеки Sinon и Testdouble.

Matchers
Библиотеки для суждений по типу - a больше b?. Уже создано множество решений, облегчающие написание утверждения для наших тестов. Jest поставляется со встроенными методами утверждения. Альтернативные популярные решения Chai и Shouldjs.

Coverage
Покрытие тестами. Есть способы определения того, какие части нашего приложения покрыты тестами. Это показатель, который служит ориентиром при определении того, насколько хорошо протестирован наш код. Jest использует популярный инструмент под названием Istanbul.

ВЫВОД
На сегодняшний день доступна целая масса фреймворков для модульного тестирования. Как видим библиотека Jest покроет любую задачу которая может возникнуть при тестировании нашего приложения.

Jest
Jest — инструмент командной строки, построенный на основе другой популярной библиотеки тестирования Jasmine. Разработкой Jest занимается Facebook, и Jest часто используется вместе с React и вполне логично фулл-стек разработчику в стеке MERN использовать для модульного тестирования именно его.

Преимущества и особенности Jest:

Встроеная в библиотеку имитация модулей JavaScript/Node упрощает изоляцию кода при модульном тестировании
Чтобы начать работать с библиотекой нет необходимости в подготовке по сравнению с другими библиотеками выполнения тестов, например для Mocha требуется импортирование Chai, подключение Istanbul и т.д.
Изолированное (sandboxed) и параллельное выполнение тестов, что приводит к ускорению их выполнения
Обеспечивает модульность, разнообразную настройку и адаптируемость
Библиотеки для модульного тестирования используют одни и те же конструкции для определения тестов и их наборов и Jest не есть исключением в этом случае.

Конструкции:

describe - набор тестов
test (или it) - тестовый случай
beforeAll - подготовка перед тестированием
beforeEach - подготовка для каждого набора или тестового случая
afterAll - завершающие действия после тестирования
afterEach - завершающие действия для каждого набора или случая
Команда describe определяет набор тестов. Он используется в качестве контейнера для набора тестов. Команда test используется для единичного теста или по другому тестового случая. Другие конструкции, такие как beforeAll, afterAll, beforeEach и afterEach, как видим из названия выполняются перед или после набора тестов или тестового случая. При beforeEach и afterEach внутрений код этих функций выполняется многократно вместо одного раза. Тесты должны содержать как минимум по одной команде describe и test и неограниченное количество. Остальные команды не являются обязательными

Давайте создадим простой пример. Для использования Jest, в новой папку проекта необходимо выполнить команду

npm init -y

Это создаст файл package.json. После установим Jest:

npm i jest -D

Теперь необходимо открыть файл package.json и вручную изменить запись команды test на jest, как показано ниже. Мы добавили команду тестирования.

{
  "name": "test-jest",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "jest"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "jest": "^26.6.1"
  }
}

Создадим модуль pow.js, который содержит функцию возведения в степень. Ее мы и будем в качестве примера тестировать.

module.exports = (a, b) => {
  return a ** b;
};

Теперь создадим файл с тестами pow.test.js. В имени он будет содержать ключевое слово test (требование Jest)

const pow = require('./pow');

describe('hooks', function () {
  beforeAll(() => {
    console.log('Выполнить в начале тестов');
  });

  afterAll(() => {
    console.log('Выполнить после тестов');
  });

  beforeEach(() => {
    console.log('Выполнить в начале каждого теста');
  });

  afterEach(() => {
    console.log('Выполнить в конце каждого теста');
  });

  test('1 to power 2 to equal 1', () => {
    console.log('1 to power 2 to equal 1');
    expect(pow(1, 2)).toBe(1);
  });

  test('3 to power 2 to equal 9', () => {
    console.log('3 to power 2 to equal 9');
    expect(pow(3, 2)).toBe(9);
  });
});

В качестве примера мы использовали все конструкции. В каждой мы выводим с помощью console.log соответствующее сообщение. Мы выполняем тестирование функции двумя тестами, где ожидаем, что функция возведения в степень вернет правильный результат.

Запуск теста производится теперь командой

npm run test

При запуске, мы должны получить такой лог в консоли:

 PASS  ./pow.test.js
  hooks
    √ 1 to power 2 to equal 1 (12 ms)
    √ 3 to power 2 to equal 9 (7 ms)

  console.log
    Выполнить в начале тестов

      at Object.<anonymous> (pow.test.js:5:13)

  console.log
    Выполнить в начале каждого теста

      at Object.<anonymous> (pow.test.js:13:13)

  console.log
    1 to power 2 to equal 1

      at Object.<anonymous> (pow.test.js:21:13)

  console.log
    Выполнить в конце каждого теста

      at Object.<anonymous> (pow.test.js:17:13)

  console.log
    Выполнить в начале каждого теста

      at Object.<anonymous> (pow.test.js:13:13)

  console.log
    3 to power 2 to equal 9

      at Object.<anonymous> (pow.test.js:26:13)

  console.log
    Выполнить в конце каждого теста

      at Object.<anonymous> (pow.test.js:17:13)

  console.log
    Выполнить после тестов

      at Object.<anonymous> (pow.test.js:9:13)

Test Suites: 1 passed, 1 total
Tests:       2 passed, 2 total
Snapshots:   0 total
Time:        3.903 s
Ran all test suites.

Обратите внимание на порядок выполнения конструкций.

В Jest используется синтаксис BDD и в основе лежит язык утверждения Expect. Перечислим основные методы Expect, которые поддерживает в Jest, остальные можно посмотреть в документации.

not — инвертирует следующее сравнение в цепочке.
expect(func(arg)).toBe(value) — проверка на строгое равенство полученного значение value
expect(func(arg)).toEqual(value) — глубокое сравнение если возвращаемые значения объект
expect(func(arg)).toBeTruthy() — проверяет значение на то, что можно ли возвращаемое значение считать истинным
expect(func(arg)).toBeNull() — проверяет значение на равенство null.
expect(func(arg)).toBeUndefined() — проверяет значение на undefined
expect(func(arg)).toBeDefined() — проверяет, что функция возвращает что-то
В expect() передается тестируемая функция, которая возвращает фактическое значение и используя методы Expect она сравнивается с ожидаемым значение, жестко заданным в тестах.

Мы разобрали библиотеку Jest которую будем использовать для написания модульных тестов.