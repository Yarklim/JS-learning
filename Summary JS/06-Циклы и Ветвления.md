Ветвления
Ветвления используются для выполнения различного кода в зависимсти от условия. Принцип работы простой - результат условия приводится к булю true или false, после чего поток программы направляется в ту или иную ветку.

Инструкция if
Синтаксис if
if (условие) {
  // тело if
}

Входные данные, которые приводятся к булю называются условием. Условие помещают за оператором if в круглых скобках. Если условие приводится к true, то выполняется код в фигурных скобках тела if.

let cost = 0;
const subscription = "pro";

if (subscription === "pro") {
  cost = 100;
}

console.log(cost); // 100

Если условие приводится к false, код в фигурных скобках будет пропущен.

let cost = 0;
const subscription = "free";

if (subscription === "pro") {
  cost = 100;
}

console.log(cost); // 0

Инструкция if...else
Синтаксис if...else
if (условие) {
  // тело if
} else {
  // тело else
}

Расширяет синтаксис if тем, что в случае если условие приводится к false, выполнится код в фигурных скобках после оператора else.

let cost;
const subscription = "free";

if (subscription === "pro") {
  cost = 100;
} else {
  cost = 0;
}

console.log(cost); // 0

Если условие приводится к true, тело блока else игнорируется.

let cost;
const subscription = "pro";

if (subscription === "pro") {
  cost = 100;
} else {
  cost = 0;
}

console.log(cost); // 100

Инструкция else...if
Синтаксис else...if
Конструкция if...else может проверить и среагировать на выполнение или невыполнение только одного условия.

Блок else...if позволяет добавить после else еще один оператор if с условием. В конце цепочки может быть классический блок else, который выполнится только в случае, когда ни одно из условий не приведётся к true.

let cost;
const subscription = "premium";

if (subscription === "free") {
  cost = 0;
} else if (subscription === "pro") {
  cost = 100;
} else if (subscription === "premium") {
  cost = 500;
} else {
  console.log("Invalid subscription type");
}

console.log(cost); // 500

При первом же true проверки прекратятся и выполнится только один сценарий, соответствующий этому true. Поэтому подобную запись следует читать как: ищу первое совпадение условия, игнорирую все остальное.

Тернарный оператор
Тернарный оператор используется как более синтаксически краткая замена инструкции if...else, когда одной и той же переменной необходимо присвоить разные значения по условию.

<условие> ? <выражение_если_условие_истинно> : <выражение_если_условие_ложно>

Работает по такой схеме:

Вычисляется условие.
Если условие истинно, то есть приводится к true, вычисляется выражение после ?.
Если условие ложно, то есть приводится к false, вычисляется выражение после :.
Значение вычисленного выражения возвращается как результат работы тернарного оператора.
let type;
const age = 20;

if (age >= 18) {
  type = "adult";
} else {
  type = "child";
}

console.log(type); // "adult"

Выполним рефакторинг заменив if...else тернарным оператором.

const age = 20;
const type = age >= 18 ? "adult" : "child";
console.log(type); // "adult"

Запишем операцию поиска большего числа.

const num1 = 5;
const num2 = 10;
let biggerNumber;

if (num1 > num2) {
  biggerNumber = num1;
} else {
  biggerNumber = num2;
}

console.log(biggerNumber); // 10

Код работает верно, получаем большее число из двух, но это решение кажется слишком громоздким, учитывая, насколько проста проблема. Используем тернарный оператор.

const num1 = 5;
const num2 = 10;
const biggerNumber = num1 > num2 ? num1 : num2;

console.log(biggerNumber); // 10

ИНТЕРЕСНО
Тернарный оператор должен использоваться в простых операциях присваивания или возврата. Его использование для описания сложных ветвлений - плохая практика (антипаттерн).

Инструкция switch
В некоторых случаях неудобство чтения сложных ветвлений if...else можно избежать используя более «плоский» синтаксис инструкции ветвления switch.

Область применения switch ограничена задачами с одним общим вопросом (что сравнивать) и множеством вариантов ответов (с чем сравнивать).

Инструкция switch
Его синтаксис состоит из блока switch(значение) - что нужно сравнить и множества отдельных случаев case значение - с чем нужно сравнить. Для сравнения используется оператор строгого равенства ===. То есть нельзя сравнить на больше или меньше, только на равенство.

switch (значение) {
  case значение:
    инструкции;
    break;

  case значение:
    инструкции;
    break;

  default:
    инструкции;
}

Значение в блоке switch(значение) - строка или число, которое сравнивается на строгое равенство со всеми значениями в блоках case значение по порядку, сверху вниз.

Оператор break в завершении каждого блока case необходим чтобы прервать дальнейшие проверки и сразу перейти к коду за switch в том случае, когда проверка на равенство вернула true.

Если ни одного совпадения значений не произошло, необходимо выполнить код по умолчанию, как в блоке else для инструкции if...else. Для этого после всех блоков case добавляется блок default. Оператор break после блока default не нужен, так как это и так последнее что будет выполнено в switch и управление будет передано коду за ним.

let cost;
const subscription = "premium";

switch (subscription) {
  case "free":
    cost = 0;
    break;

  case "pro":
    cost = 100;
    break;

  case "premium":
    cost = 500;
    break;

  default:
    console.log("Invalid subscription type");
}

console.log(cost); // 500

ИНТЕРЕСНО
Если оператор break будет отсутствовать, то после того как выполнится какое-то условие case, все последующие за ним блоки кода будут выполняться один за другим, что может привести к нежелательным последствиям при неверном применении.

Область видимости
Область видимости переменных (variable scope) - доступность переменных в определённом месте кода.

Глобальная область видимости используется по умолчанию. Все и вся имеют доступ к переменным объявленным в ней. Например, переменная value объявлена в глобальной области видимости, то есть вне какого-то блока, и доступна в любом месте после объявления.

const value = 5;

if (true) {
  console.log("Block scope: ", value); // 5
}

console.log("Global scope: ", value); // 5

Любая конструкция использующая фигурные скобки {} (условия, циклы, функции и т. п.) создает новую локальную область видимости, и переменные, объявленные в этой области видимости, используя let или const, не доступны вне этого блока.

if (true) {
  const value = 5;
  console.log("Block scope: ", value); // 5
}

console.log("Global scope: ", value); // ReferenceError: value is not defined

Глубина вложенности областей видимости не ограничена, и все они буду работать по одному принципу - область видимости имеет доступ ко всем переменным объявленным выше по иерархии вложенности, но не может получить доступ к переменным объявленным во вложенных областях видимости.

Создадим несколько областей видимости и дадим им имена для наглядности.

Области видимости
Глобальная есть по умолчанию, создадим в ней переменную global
Далее используя оператор if создадим блочную область видимости block A
Внутри области видимости block A поставим еще один оператор if, который создаст вложенную область видимости block B
На одном уровне с block A, создадим область видимости block C все так же используя оператор if
const global = "global";

if (true) {
  const blockA = "block A";

  // Видим глобальную + локальную A
  console.log(global); // 'global'
  console.log(blockA); // block A

  // Переменные blockB и blockC не найдены в доступных областях видимости.
  // Будет ошибка обращения к переменной.
  console.log(blockB); // ReferenceError: blockB is not defined
  console.log(blockC); // ReferenceError: blockC is not defined

  if (true) {
    const blockB = "block B";

    // Видим глобальную + внешнюю A + локальную B
    console.log(global); // global
    console.log(blockA); // block A
    console.log(blockB); // block B

    // Переменная blockC не найдена в доступных областях видимости.
    // Будет ошибка обращения к переменной.
    console.log(blockC); // ReferenceError: blockC is not defined
  }
}

if (true) {
  const blockC = "block C";

  // Видим глобальную + локальную C
  console.log(global); // global
  console.log(blockC); // block C

  // Переменные blockA и blockB не найдены в доступных областях видимости.
  // Будет ошибка обращения к переменной.
  console.log(blockA); // ReferenceError: blockA is not defined
  console.log(blockB); // ReferenceError: blockB is not defined
}

// Видим только глобальную
console.log(global); // global

// Переменные blockA, blockB и blockC не найдены в доступных областях видимости.
// Будет ошибка обращения к переменной.
console.log(blockA); // ReferenceError: blockA is not defined
console.log(blockB); // ReferenceError: blockB is not defined
console.log(blockC); // ReferenceError: blockC is not defined

ИНТЕРЕСНО
Будьте внимательны при использовании блочных областей видимости и переменных объявленных в них. Именно эта ошибка, вместе с невнимательностью, часто становится головной болью новичка.

Циклы
Частая задача программирования - выполнение однотипного действия много раз. Например, вывести клиентов из списка один за другим, или перебрать суммы зарплат и для каждой выполнить одинаковый код. Именно для таких целей - многократного повторения одного участка кода, используются циклы.

Цикл - управляющая конструкция в высокоуровневых языках программирования, предназначенная для организации многократного исполнения набора инструкций.
Тело цикла - последовательность инструкций, предназначенная для многократного исполнения.
Итерация - единичное выполнение тела цикла.
Условие выхода - выражение, определяющее будет в очередной раз выполняться итерация, или цикл завершится.
Счётчик - переменная, хранящая текущий номер итерации. Цикл не обязательно содержит счётчик, и он не обязан быть один, условие выхода из цикла может зависеть от нескольких изменяемых в цикле переменных.
Цикл while
Цикл с предусловием — цикл, который выполняется пока истинно некоторое условие, указанное перед его началом. Это условие проверяется до выполнения тела цикла, поэтому тело может быть не выполнено ни разу, если условие с самого начала ложно.

while (condition) {
  // код, тело цикла (statement)
}

Конструкция while создает цикл, который выполняет блок кода, пока условие проверки оценивается как true.

condition, то есть условие, вычисляется перед каждой итерацией цикла.
Если condition оценивается как true, оператор while выполняет statement.
Если condition оценивается как false, выполнение цикла прерывается и скрипт продолжает выполнять инструкции после цикла while.
Блок-схема иллюстрирует цикл while.

while loop
Сделаем счетчик.

let counter = 0;

while (counter < 10) {
  console.log("counter: ", counter);
  counter += 1;
}

Будем заполнять места в отеле до тех пор пока текущее количество клиентов не будет равно максимально допустимому.

let clientCounter = 18;
const maxClients = 25;

while (clientCounter < maxClients) {
  console.log(clientCounter);
  clientCounter += 1;
}

Цикл do...while
Цикл с постусловием - цикл, в котором условие проверяется после выполнения тела цикла. Отсюда следует, что тело всегда выполняется хотя бы один раз.

do {
  // statement
} while (condition);

Конструкция do...while создает цикл, который выполняет блок кода до тех пор, пока condition не вернёт false.

В отличие от цикла while, цикл do...while всегда выполняет statement как минимум один раз, прежде чем он оценит condition.

Внутри цикла нужно внести изменения в некоторую переменную, чтобы убедиться, что выражение равно false после итераций. В противном случае будет бесконечный цикл.

Блок-схема иллюстрирует цикл do-while

do...while loop
let password = "";

do {
  password = prompt("Введите пароль длиннее 4-х символов", "");
} while (password.length < 5);

console.log("Ввели пароль: ", password);

Цикл for
Цикл со счётчиком - цикл, в котором некоторая переменная изменяет своё значение от заданного начального до конечного значения с некоторым шагом и для каждого значения этой переменной тело цикла выполняется один раз.

В большинстве процедурных языков программирования реализуется конструкцией for, в которой указывается счётчик, требуемое количество итераций и шаг, с которым изменяется счётчик.

for (initialization; condition; post-expression) {
  // statements
}

Алгоритм исполнения цикла for:

Инициализация (initialization) - выполняется один раз перед началом цикла. Используется для создания переменной-счётчика и указания её начального значения.
Условие (condition) - выражение, оцениваемое перед каждой итерацией (повторением) цикла. Тело цикла выполняется только тогда, когда выражение приводится к true. Цикл завершается, если значение будет false.
Тело (statements) - набор инструкций для выполнения на каждом повторении. Выполняется если выражение условия приводится к true.
Пост-выражение (post-expression) - выполняется в конце каждого повторения цикла, перед проверкой условия. Используется для обновления переменной-счётчика.
Переменные-счетчики, по традиции, называются буквами i, j и k.

for (let i = 0; i <= 20; i += 5) {
  console.log(i);
}

В примере объявляется перемнная-счетчик i, инициализируется значением 0 и цикл выполняется до тех пор, пока i <= 20, то есть условие приводится к true. После каждой итерации счётчик увеличивается на 5.

Посчитаем сумму чисел до определенного значения.

const target = 3;
let sum = 0;

for (let i = 0; i <= target; i += 1) {
  sum += i;
}

console.log(sum);

Вспомним про операцию a % b и выведем остаток от деления используя цикл.

const max = 10;
for (let i = 0; i < max; i += 1) {
  console.log(`${max} % ${i} = `, max % i);
}

Оператор break
Прервать выполнение цикла можно в любой момент. Для этого сущестует оператор break, который полностью прекращает выполнение цикла и передаёт управление на строку за его телом.

Найдём число 3. Как только выполнится условие if, цикл прекратит своё выполнение (будет прерван).

for (let i = 0; i <= 5; i += 1) {
  console.log(i);

  if (i === 3) {
    console.log("Нашли число 3, прерываем выполнение цикла");
    break;
  }
}

console.log("Лог после цикла");

Оператор continue
Прерывает не весь цикл, а только выполнение текущей итерации. Его используют, если понятно, что на текущей итерации цикла делать больше нечего или вообще ничего делать не нужно и пора переходить на следующую итерацию.

Используем цикл для вывода только нечетных чисел. Для чётных i срабатывает continue, выполнение тела прекращается и управление передаётся на следующую итерацию.

const number = 10;

for (let i = 0; i < number; i += 1) {
  if (i % 2 === 0) {
    continue;
  }

  console.log("Нечетное i: ", i); // 1, 3, 5, 7, 9
}

# ============ Метка - прерывание родительского цикла из дочернего цикла =============
Чтобы прервать выполнение родительского цикла из дочернего цикла, необходимо использовать break с меткой:

firstFor: for (let num = 0; num < 2; num++) {
	for (let size = 0; size < 3; size++) {
		if (size === 2) {
			break firstFor;
		}
		console.log(size);
	}
}

Так же работает и с continue.