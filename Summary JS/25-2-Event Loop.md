Как устроен цикл событий
Машина читает код дважды: сначала в память компьютера записываются переменные, потом происходит непосредственное выполнение кода. Часто задач в коде несколько: они попадают в цикл событий (Event Loop) и выполняются в определённой последовательности.

Последовательность задаётся типом кода: синхронным или асинхронным. В случае с синхронным кодом все задачи попадают сразу в Call Stack и выполняются по очереди.

Асинхронный код используется, например, когда программе нужно обратиться к базе данных или другому внешнему источнику информации. Этот процесс можно сравнить с телефонным звонком: когда вы звоните кому-то, вы заранее не знаете, когда вам ответят — после первого гудка, после пятого или вообще не возьмут трубку.

С асинхронным кодом сложнее: во-первых, он всегда выполняется после синхронного, а во-вторых, делится ещё на две очереди — макро- и микрозадачи.

Микрозадачи — в основном, промисы, которые выполняются в первую очередь. Большие задачи (например, таймеры, AJAX-запросы) попадают в самый конец стека и выполняются последними.



# ============= Задачи ==============

# Задача первая
// В каком порядке будут выведены консоли и какие именно?
const p = new Promise((resolve, reject) => {
  reject(Error('Всё сломалось :('));
})
  .catch((error) => console.log('1-я', error.message))
  .catch((error) => console.log('2-я', error.message));

  Прежде чем разбирать код, рассмотрим пример, к которому мы будем возвращаться на протяжении всей статьи. Он поможет глубже понять принцип работы асинхронного кода.

Представьте, что вы пришли в фастфуд, сделали заказ, получили специальный пульт и ждёте, пока пульт завибрирует и можно будет пойти и забрать заказ.

В первой строке кода мы видим promise — это специальный объект, который даёт обещание, что в будущем будет выполнено то или иное действие. Promise выступает аналогом такого пульта и в данном случае обещает уведомить не о готовности заказа, а об ошибке, если она возникнет.

Под promise прописан вариант развития событий — reject, который выводит в консоль сообщение «Всё сломалось» в случае, если что-то пошло не так. Второй, положительный, вариант resolve в этой задаче не указан.

Вернёмся к примеру с фастфудом: вы сели за столик и ждёте заказ. Через некоторое время пульт завибрировал. Дальше может быть несколько вариантов развития событий: вы успешно получите заказ или кассир позовёт вас сообщить, что какого-то ингредиента нет и блюдо не смогут приготовить. На этот случай и нужны resolve и reject.

Следующий шаг — встать и подойти к стойке. За него отвечают обработчики .catch, которые в коде идут в цепочке друг за другом. Это важный момент: между обработчиками нет точки с запятой, и цепочка идёт сразу после объявления переменной ‘p’, поэтому выполняется только первый .catch. Второй выполняет те же действия и не срабатывает.

Это сравнительно простая задача: в ней нет смешивания синхронного и асинхронного кода. В консоли мы получим результат выполнения promise, а затем — вывод первого .catch.

Дополнение первое
const p2 = new Promise((resolve, reject) => {
  reject(Error('Всё сломалось :('));
});
// тут обе консоли, потому что нет цепочки, каждый catch отрабатывает отдельно
p2.catch((error) => console.log('3-я', error.message));
p2.catch((error) => console.log('4-я', error.message));

Здесь происходит то же самое, что и в базовом варианте задачи, но с исключениями. Есть два обращения к константе ‘p2’, нет цепочки, между .catch появилась точка с запятой, поэтому в консоль выводится результат обоих обработчиков.

Стоит отметить, что смысла в этом немного: обработчики отлавливают одну и ту же ошибку. Но эта задача скорее на внимательность, чем на логику.

Дополнение второе
const p3 = new Promise((resolve, reject) => {
  reject(Error('Всё сломалось :('));
})
  .then((error) => console.log('5-я', error.message)) // ? бесполезный обработчик положительного ответа
  .catch((error) => console.log('6-я', error.message)); // ? будет отлов ошибки

В этой версии задачи есть then. Здесь это обработчик положительного результата (resolve), который не выполняет никакую функцию, в этом коде он бесполезен. В тексте задачи по-прежнему упоминается только негативное развитие событий. Поэтому вывод в консоль будет тот же, что и в предыдущей задаче.

# Задача два
// в каком порядке будут выведены консоли и что в них будет?
setTimeout(() => {
  console.log('timeout')
}, 0);

const p = new Promise((resolve, reject) => {
  console.log('Promise creation');
  resolve()
})

const p2 = new Promise((resolve, reject) => {
  console.log(123)
})

p.then(() => {
  console.log('Promise resolving');
})

console.log('End')

console.log('p2 =>>', p2)

Разберём текст задачи. В первой строчке указан таймер setTimeout с нулевой задержкой, следом идут два promise: c пустой функцией обработки положительного ответа и без функции.

Здесь then — обработчик первого promise, который получает результат выполнения resolve. В последних строчках — консоль завершения и консоль, которая выводит результат выполнения второго promise.

Вспомним, в каком порядке код попадает в Call Stack. В первую очередь выполняется синхронный код: console.log или promise. По дефолту они не асинхронные, пока вы не сделаете их таковыми (например, добавите .catch или .then).

Таким образом, вывод консоли будет иметь следующий порядок:
setTimeout(() => {
  console.log('timeout') // 6) макрозадача, timeout
}, 0);
const p = new Promise((resolve, reject) => {
  console.log('Promise creation'); // 1) синхронно, Promise creation
  resolve()
})

const p2 = new Promise((resolve, reject) => {
  console.log(123) // 2) синхронно, 123
})

p.then(() => {
  console.log('Promise resolving'); // 5) пришёл из микрозадачи после всего синхронного кода, Promise resolving
})

console.log('End') // 3) синхронно, End

console.log('p2 =>>', p2) // 4) синхронно, Promise {  }

Строки с консолями внутри promise выполнятся в первую очередь, поскольку в них нет ничего асинхронного, так как promise сам по себе изначально синхронный. Затем выполняются синхронная консоль ‘End’ и консоль, в которой показывается второй promise, находящийся в стадии ожидания (<pending>).

Далее выполняется .then. В базовом варианте promise выполняется синхронно. Только после того, как весь синхронный код отработал, выполняется его асинхронный обработчик. В последнюю очередь выполнится макрозадача с setTimeout.

# Задача три
// todo в каком порядке будут выведены консоли и что в них будет?
console.log('script start'); // ? 1) синхронно, script start


setTimeout(function() {
  console.log('setTimeout'); // ? 5) макрозадача, setTimeout
}, 0);


Promise
  .resolve()
  .then(function() {
  console.log('promise1'); // ? 3) микрозадача, promise1
})
  .then(function() {
  console.log('promise2'); // ? 4) микрозадача, promise2
});

console.log('script end'); // ? 2) синхронно, script end

В этой задаче первый и последний console.log синхронные, поэтому они выполнятся сразу. Следом идёт promise с двумя обработчиками, которые выстроены в цепочку и выполняются друг за другом. Обратите внимание, что между ними нет точки с запятой. В последнюю очередь выполняется setTimeout, поскольку это макрозадача.

Эти задачи рассчитаны на базовое понимание работы асинхронного кода. В следующей части статьи разберём более сложные кейсы и оптимизируем скорость выполнения задач в Call Stack.

# Задача 4
let a;let p4 = new Promise(function (resolve) {  console.log('TEST A1', a);  a = 25;  setTimeout(() => {    console.log('TEST A2', a);    resolve(a);  }, 100);});setTimeout(function timeout() {  a = 10;  console.log('TEST A3', a);}, 100);p4.then(function (b) {  console.log('TEST A4', a);});console.log('TEST A5', a);

Разберём задачу подробно. В первой строке объявляется переменная без присвоения значения, после которой создаётся promise и вывод в консоль значения a. Все перечисленные строки — это синхронный код, поскольку сам по себе promise не является асинхронным.

После этого ей присваивается значение: a = 25. Следующим шагом появляется таймер setTimeout, внутри которого вывод значения переменной в консоль и функция resolve, в которую вкладывается переменная ‘a’ для успешного исполнения promise c задержкой в 100 миллисекунд.

Если предыдущий таймер находился внутри promise, то второй setTimeout написан как отдельная функция. Здесь переменной ‘a’ присваивается новое значение, которое выводится в консоль с задержкой в 100 миллисекунд. На последних трёх строчках — обработка promise через then, которая завершается выводом консоли. Очередность вывода и переменная ‘a’ будут выглядеть следующим образом:

let a;let p4 = new Promise(function (resolve) {  console.log('TEST A1', a); // 1)синхронно, a = undefined  a = 25;  setTimeout(() => {    console.log('TEST A2', a); // 3)асинхронно, a = 25    resolve(a);  }, 100);});setTimeout(function timeout() {  a = 10;  console.log('TEST A3', a); // 5)асинхронно, a =  10}, 100);p4.then(function (b) {  console.log('TEST A4', a); // 4)асинхронно, a =  25});console.log('TEST A5', a); // 2)синхронно, a = 25

С точки зрения очерёдности самая запутанная часть задачи — promise, внутри которого находится setTimeout. Базово таймер относится к макрозадачам, которые попадают в Call Stack последними и выполняются в последнюю очередь. Поскольку в этой задаче он находится внутри promise — микрозадачи, которая выполняется раньше, — в вывод он попадёт третьим. Сразу после того, как отработал весь синхронный код.

Если говорить о значениях, которые выводятся в консоль, то в первой строке будет undefined, поскольку никакое значение на этом этапе переменной не присвоено. Это произойдёт только в следующей строке. Консоль, которая выполняется во вторую очередь, выдаст значение 25, так как она расположена в конце кода, и к моменту её появления значение переменной уже присвоено. В следующих выводах в консоль выводится значение переменной.

# Задача 5
// todo Объяснить код, рассказать какие консоли и в какой последовательности будут, а затем предложить более оптимальное решениеfunction resolveAfter2Seconds(x) {  console.log(`Какой Х пришёл -> ${x}`)  return new Promise(resolve => {    setTimeout(() => {      resolve(x); //    }, 5000);  });}async function add1(x) {  console.log('add1 Hello')  const a = await resolveAfter2Seconds(20);  const b = await resolveAfter2Seconds(30);  console.log('add1 Bye')  return x + a + b;}add1(10).then(console.log);

В этой задаче появляется функция async. Прежде чем приступить к разбору, вспомним, для чего она нужна.

Функция async позволяет работать с асинхронным кодом так, будто он синхронный. Синхронный код не работает с асинхронным, но в пределах функции async возможно сделать вид, что так можно. Для этой задачи важно отметить, что любая async-функция сразу же возвращает promise. В паре с async идёт ключевое слово await, которое буквально означает «дождись». Сама по себе async-функция, как и promise — не является асинхронной.

Перейдём к разбору кода. В первой строке находится функция resolveAfter2Seconds, которая принимает аргумент x, выводит его значение в консоль и возвращает его в promise с задержкой в пять секунд.

Далее следует функция async. Внутри неё — синхронная консоль, за которой следуют две асинхронные функции, которые «дожидаются» своего выполнения через await. Результат их поочередного выполнения попадает в promise, а аргумент x приобретает значение сначала ‘a’, а затем — ‘b’. Затем выводится результат Bye.

В последней строчке функции указан вывод результата. Так как любая async возвращает promise, в return не удастся получить конкретного результата. Вместо него мы получим promise pending — ожидание. Then в последней строчке — обработчик этого pending.

В результате порядок выполнения будет следующим:

function resolveAfter2Seconds(x) {  console.log(`Какой Х пришёл -> ${x}`) // 2) Какой Х пришёл -> 20 undefined 3) Какой Х пришёл -> 30  return new Promise(resolve => {    setTimeout(() => {      resolve(x); //    }, 5000);  });}async function add1(x) {  console.log('add1 Hello') // 1)add1 Hello   const a = await resolveAfter2Seconds(20);  const b = await resolveAfter2Seconds(30);  console.log('add1 Bye') // 4)add1 Bye  return x + a + b;}add1(10).then(console.log); // 5)60

Этот код работает медленно: чем больше внутри async-функции add1 вызовов функций resolveAfter2Seconds с ожиданием (await), тем больше времени займёт его выполнение. Если вызовов два, то он будет выполняться 10 секунд. Если их будет 10, ждать придётся почти минуту.

Попробуем переписать код и сократить время ожидания. Поставим все вызовы в очередь без await, чтобы они выполнялись все одновременно за пять секунд:

async function add2(x) {  console.log('add2 Hello')  const p_a = resolveAfter2Seconds(200);  const p_b = resolveAfter2Seconds(300);  const p_c = resolveAfter2Seconds(100);  const p_d = resolveAfter2Seconds(999);  console.log('add2 Bye')  return x + await p_a + await p_b + await p_c + await p_d;}add2(400).then(console.log);

Теперь мы дожидаемся выполнения всех функций уже в конце и только после этого показываем конечный результат. В результате оптимизации ждать придётся не 20 секунд, а всего пять.