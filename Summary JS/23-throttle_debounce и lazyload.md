# Throttle и Debounce
Довольно часто необходимо обработать изменение размера окна, скролл, перемещение мыши или текстовый ввод пользователя. Это может быть сортировка коллекции и отрисовка результатов, анимация элемента, манипуляции с DOM-деревом и прочее. Все это улучшает UX (user experience), но, к сожалению, даёт большую нагрузку на браузер из-за того, что обработчики событий срабатывают слишком часто. Такие события неофициально называют «chatty events».

Например, если добавить слушателя события на скролл, то при прокрутке страницы мышкой можно вызвать около 30 событий в секунду. Медленная прокрутка (свайп) в смартфоне может вызвать до 100 событий в секунду. Если обработчик события скролла выполняет тяжелые вычисления и другие DOM-манипуляции, гарантированно будут проблемы с производительностью.


Throttle и Debounce - это два похожих, но разных по поведению приёма, позволяющих контролировать сколько раз мы разрешаем выполнение функции с течением времени. Используем их реализацию из библиотеки Lodash.

Подключение библиотеки
CDN (Content Delivery Network) - это географически распределённая сетевая инфраструктура, обеспечивающая быструю доставку контента пользователям веб-сервисов и сайтов. Входящие в состав CDN cерверы географически располагаются таким образом, чтобы сделать время ответа для пользователей сайта/сервиса минимальным.

Подключим в проект библиотеку Lodash через CDN. Для этого используем сервис cdnjs.com и добавим ссылку на скрипт библиотеки в конец HTML-документа, как показано в примере.

index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Document title</title>
  </head>
  <body>
    <!-- HTML-markup -->

    <!-- Lodash library script file -->
    <script
      async
      src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"
      integrity="sha512-WFN04846sdKMIP5LKNphMaWzU7YpMyCU245etK3g/2ARYbPK9Ub18eG+ljU96qKRCWh+quCY7yefSmlkQw1ANQ=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <!-- Your script file -->
    <script defer src="path/to/script.js"></script>
  </body>
</html>


Теперь мы можем получить доступ к библиотеке в нашем скрипте. При подключении библиотек через CDN, на объект window добавляется свойство в котором хранится то, что предоставляет библиотека. Имя этого свойства уникально для библиотеки и описано в её документации. Для Lodash это символ нижнего подчёркивания _. Для проверки используем метод add, который просто складывает два числа.

script.js
const result = _.add(2, 3);
console.log(result); // 5

# Throttle
Прием throttle контролирует количество раз которое функция может быть вызвана в течение промежутка времени. То есть позволяет вызывать функцию не чаще чем один раз в N миллисекунд, гарантируя ее регулярное выполнение.

Event throttling
Используя throttle мы не контролируем, как часто браузер будет генерировать события. Мы всего-лишь берем контроль над частотой выполнения функции обработчика события.

document.addEventListener(
  "scroll",
  _.throttle(() => {
    console.log("Scroll handler call every 300ms");
  }, 300)
);

Реализация из библиотеки Lodash ожидает первым аргументом функцию которую необходимо «затормозить», а вторым количество миллисекунд. Возвращает новую функцию для передачи в слушатель события.


# Debounce
Прием debounce гарантирует, что функция будет вызвана только если между событиями будет пауза в N миллисекунд. Например, пока пользователь скролит страницу функция не вызовется, но как только он перестал скролить, функция будет вызвана через 300 миллисекунд. Если скролл возобновится раньше чем через 300 миллисекунд после паузы, функция не вызовется.

Trailing edge debounce
Используя debounce мы не управляем тем как часто браузер будет генерировать события, а всего-лишь берем контроль над частотой выполнения функции обработчика события.

document.addEventListener(
  "scroll",
  _.debounce(() => {
    console.log("Scroll handler call after 300ms pause");
  }, 300)
);

Реализация из библиотеки Lodash ожидает первым аргументом функцию, а вторым количество миллисекунд. Возвращает новую функцию для передачи в слушатель события.


Режимы метода debounce
По умолчанию метод debounce работает в режиме когда функция вызывается через N миллисекунд после паузы между потоками событий. Этот режим называется trailing edge (в конце). Есть задачи когда функцию надо вызвать сразу при наступлении первого события в потоке, а потом игнорировать все последующие события, до паузы между ними, например в 300 миллисекунд. На старте следующего потока событий это поведение повторяется. Такой режим называется leading edge (в начале).

Leading edge debounce
Методу debounce библиотеки Lodash можно передать необязательный третий аргумент - обьект параметров в котором есть два свойства leading (по умолчанию false) и trailing (по умолчанию true). Эти настройки изменяют режим и указывают, должна ли функция запускаться в начале потока событий или в конце после паузы.

document.addEventListener(
  "scroll",
  _.debounce(
    () => {
      console.log("Scroll handler call on every event stream start");
    },
    300,
    {
      leading: true,
      trailing: false,
    }
  )
);

На практике режим leading может применяться например в случае когда необходимо выполнить функцию отправки запроса на сервер при первом клике кнопки, после чего игнорировать все послудующие клики до паузы. В примере реализован debounce в обоих режимах для события scroll.

# Отложенная загрузка
Веб-страницы содержат большое количество изображений, которые раздувают размер страниц и влияют на скорость их загрузки. Большинство изображений находятся за пределами первого экрана (за кадром, below the fold), поэтому пользователь увидит их только после того как прокрутит страницу. Это значит, что вы возможно загружаете то, что пользователь никогда не увидит, но потратит на это время и возможно деньги. Загрузка некритического контента также тратит батарею мобильных устройств и другие системные ресурсы.

Above and below the fold
Термины «above the fold» (в кадре) и «below the fold» (за кадром) пришли из времен до появления цифровых технологий. Если вы когда-либо покупали газету в киоске, их обычно складывают пополам, чтобы прохожие могли видеть только верхнюю половину первой страницы. Если им не понравится то, что они увидят, они пройдут мимо, и продажи упадут. Вот почему так важно размещать наиболее интересный контент в верхней части страницы.

Отложенная загрузка (lazy-loading) - это приём, который откладывает загрузку некритических ресурсов во время загрузки страницы. Вместо этого, эти некритические ресурсы загружаются только по необходимости. Это снижает начальный вес ресурсов которые необходимо загрузить для отображения страницы, использование системных ресурсов, повышает время её загрузки и последущего рендера. Все это положительно сказывается на производительности.

Вы, наверное, уже видели в действии ленивую загрузку. Она выглядит примерно так:

Вы попадаете на страницу и начинаете прокручивать её по мере чтения содержимого.
В какой-то момент вы прокручиваете страницу до изображения-заглушки.
Изображение-заглушка внезапно заменяется настоящим изображением.
Атрибут loading
Раньше разработчикам приходилось полагаться только на возможности JavaScript. Современные браузеры умеют делать это без JavaScript, но, к сожалению, не все. HTML-атрибут loading тега <img> поддерживается нативно во всех современных браузерах кроме Safari и позволяет браузеру отложить загрузку закадровых изображений до тех пор, пока пользователь не прокрутит до них страницу.

<img src="my-image.jpg" loading="lazy" alt="Image description" />

Поддерживает три значения:

lazy - браузер выполнит отложенную загрузку изображения.
eager - изображение будет загружено при первой возможности, то есть без отложенной загрузки.
auto - браузер сам определяет, выполнять отложенную загрузку или нет. Значение по умолчанию.
Мы не можем узнать или изменить поведение и механизм определения времени отложенной загрузки изображения браузером. Главное, что браузер загрузит такие изображения незадолго до того, как они попадут в область просмотра.

Откройте вкладку Network в инструментах разработчика и выберите фильтр Img, чтобы отображалась только загрузка изображений. После этого прокручивайте пример и наблюдайте как будут догружаться закадровые изображения котов. Браузеры поддерживающие атрибут loading будут загружать изображения отложенно, а браузеры без поддержки загрузят все изображения сразу.


Библиотека lazysizes
Чтобы обеспечить кроссбраузерность, то есть совместимость с более старыми браузерами, или такими которые еще не поддерживают это нативно, можно использовать ряд существующих JavaScript библиотек. Одни из самых популярных это lazysizes, vanilla-lazyload и lozad.js. Выбор библиотеки сводится к набору предоставляемых возможностей и личным предпочтениям. Мы разберем библиотеку lazysizes.

ИНТЕРЕСНО
Нативная поддержка лучше и более производительна чем использование библиотек, но они гарантированно работают во всех браузерах и могут предоставлять расширенные возможности отложенной загрузки которых еще нет в стандарте.

Первое что необходимо сделать это подключить библиотеку в проект используя сервис cdnjs.com. Тег с ссылкой на скрипт добавляется в конец <body>, также как мы это делали для библиотеки Lodash.

index.html
<body>
  <!-- HTML-markup -->

  <!-- Lazysizes library script file -->
  <script
    src="https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.3.2/lazysizes.min.js"
    integrity="sha512-q583ppKrCRc7N5O0n2nzUiJ+suUv7Et1JGels4bXOaMFQcamPk9HjdUknZuuFjBNs7tsMuadge5k9RzdmO+1GQ=="
    crossorigin="anonymous"
    referrerpolicy="no-referrer"
  ></script>
  <!-- Your script file -->
  <script defer src="path/to/script.js"></script>
</body>


ИНТЕРЕСНО
Библиотека lazysizes самоинициализируется при загрузке на страницу. То есть для базового использования в JavaScript ничего делать не надо. Полный список её возможностей приведён в документации.

Всем изображениям которые необходимо загружать отложенно задаём класс lazyload и заменяем атрибут src на data-src. Это необходимо библиотеке lazysizes для правильной работы.

index.html
<img class="lazyload" data-src="path/to/my-image.jpg" alt="Generic alt" />

Пока изображение загружается можно показывать заполнитель низкого качества. Эта техника называется LQIP (Low Quality Image Placeholder). Есть много вариантов реализации LQIP, но для начала достаточно будет показывать один стандартный заполнитель вместо всех изображений. Для этого добавляем атрибут src, значением которого будет ссылка на это изображение-заполнитель.

index.html
<img
  class="lazyload"
  src="path/to/lqip-placeholder.jpg"
  data-src="path/to/my-image.jpg"
  alt="Generic alt"
/>

Когда изображение было загружено, библиотека lazysizes добавляет элементу класс lazyloaded. Это можно использовать для применения CSS-эффектов в момент загрузки изображения.

styles.css
.blur-up {
  filter: blur(5px);
  transition: filter 400ms;
}

.blur-up.lazyloaded {
  filter: blur(0);
}

После объявления стилей, добавляем класс blur-up тегам <img>.

index.html
<img
  class="lazyload blur-up"
  src="path/to/lqip-placeholder.jpg"
  data-src="path/to/my-image.jpg"
  alt="Generic alt"
/>

Применим все эти шаги на примере, добавив кроссбраузерную поддержку отложенной загрузки изображений нашему сайту про котов. Теперь даже Safari выполняет отложенную загрузку изображений.

