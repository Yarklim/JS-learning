/*
849. Maximize Distance to Closest Person
Вам дан массив, представляющий строку seatsгде seats[i] = 1представляет человека, 
сидящего на сиденье, и представляет, что место пусто (индексировано 0) .ithseats[i] = 0ith

Есть по крайней мере одно свободное место и по крайней мере один сидящий человек.

Алекс хочет сесть на сиденье так, чтобы расстояние между ним и ближайшим к нему человеком было максимальным. 

Верните это максимальное расстояние ближайшему человеку .
*/
var maxDistToClosest = function (seats) {
  let max = 0;
  let count = 0;
  let i = 0;

  if (seats[i] === 0) {
    while (seats[i] === 0) {
      i++;
      count += 1;
    }
    max = count;
    count = 0;
  }

  for (; i < seats.length; i++) {
    if (i === seats.length - 1 && seats[i] === 0) {
      count += 1;
      max = Math.max(max, count);
      break;
    }
    if (seats[i] === 1) {
      count = 0;
    } else {
      count += 1;
      max = Math.max(max, Math.ceil(count / 2));
    }
  }
  return max;
};
// console.log(maxDistToClosest([1, 0, 0, 0, 1, 0, 1])); // 2
// console.log(maxDistToClosest([1, 0, 0, 0])); // 3
// console.log(maxDistToClosest([0, 1])); // 1
// console.log(maxDistToClosest([0, 0, 0, 0, 1, 0, 0, 0, 1])); // 4

//? ==============================================
/*
345. Reverse Vowels of a String

Given a string s, reverse only all the vowels in the string and return it.

The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.

Example 1:
Input: s = "hello"
Output: "holle"

Example 2:
Input: s = "leetcode"
Output: "leotcede"
*/
/**
 * @param {string} s
 * @return {string}
 */
var reverseVowels = function (s) {};
// console.log(reverseVowels('hello')); // "holle"
// console.log(reverseVowels('leetcode')); // "leotcede"

//? ==============================================
/*
389. Find the Difference

You are given two strings s and t.

String t is generated by random shuffling string s and then add one more letter at a random position.

Return the letter that was added to t.

Example 1:
Input: s = "abcd", t = "abcde"
Output: "e"
Explanation: 'e' is the letter that was added.

Example 2:
Input: s = "", t = "y"
Output: "y"
*/
/**
 * @param {string} s
 * @param {string} t
 * @return {character}
 */
var findTheDifference = function (s, t) {};
// console.log(findTheDifference('abcd', 'abcde')); // "e"
// console.log(findTheDifference('', 'y')); // "y"

//? ==============================================
/*
560. Subarray Sum Equals K

Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.

A subarray is a contiguous non-empty sequence of elements within an array.
*/
const fun = (arr, k) => {};

// console.log(fun([1, 2, 3], 3)); // 2
// console.log(fun([1, 2, 3], 4)); // 0
// console.log(fun([1, -1, 0], 0)); // 3
// console.log(fun([3, 4, 7, -2, 2, 1, 4, 2], 7)); // 5

//? ==============================================
/*

*/

//? ==============================================
/*

*/

//? ==============================================
/*

*/

//? ==============================================
/*

*/

//? ==============================================
/*

*/

//? ==============================================
/*

*/

//? ==============================================
/*

*/

//! ==============================================

/*
94. Binary Tree Inorder Traversal

Учитывая root бинарное дерево, 
вернуть неупорядоченный обход значений его узлов .

Пример 1:
Ввод: корень = [1,null,2,3]
 Вывод: [1,3,2]

Пример 2:
Ввод: корень = []
 Вывод: []

Пример 3:
Ввод: корень = [1]
 Вывод: [1]
 
Ограничения:
Количество узлов в дереве находится в диапазоне [0, 100].
-100 <= Node.val <= 100 

Продолжение: рекурсивное решение тривиально, 
можете ли вы сделать это итеративно?
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function (root) {};

// console.log(inorderTraversal([1, null, 2, 3]));
// console.log(inorderTraversal([]));
// console.log(inorderTraversal([1]));

//? ==============================================
/*
100. Same Tree

Имея корни двух бинарных деревьев pи q, напишите функцию, 
проверяющую, совпадают ли они или нет.

Два бинарных дерева считаются одинаковыми, 
если они структурно идентичны, а узлы имеют одинаковое значение.

 Пример 1:
Вход: p = [1,2,3], q = [1,2,3]
 Выход: правда

Пример 2:
Ввод: p = [1,2], q = [1,null,2]
 Вывод: false

Пример 3:
Вход: p = [1,2,1], q = [1,1,2]
 Выход: ложь
 
Ограничения:

Количество узлов в обоих деревьях находится в диапазоне [0, 100].
-104 <= Node.val <= 104
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function (p, q) {};
// console.log(isSameTree([1, 2, 3]));
// console.log(isSameTree([1, 2]));
// console.log(isSameTree([1, 2, 1]));

//? ==============================================
/*
101. Symmetric Tree

Учитывая rootбинарное дерево, проверьте, 
является ли оно зеркалом самого себя 
(т. е. симметричным относительно своего центра).

Пример 1:
Ввод: корень = [1,2,2,3,4,4,3]
 Вывод: правда

Пример 2:
Ввод: root = [1,2,2,null,3,null,3]
 Вывод: false
 
Ограничения:
Количество узлов в дереве находится в диапазоне [1, 1000].
-100 <= Node.val <= 100
 
Дополнение: Могли бы вы решить это как рекурсивно, так и итеративно?
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function (root) {};
// console.log(isSymmetric([1, 2, 2, 3, 4, 4, 3]));
// console.log(isSymmetric([1, 2, 2, null, 3, null, 3]));

//? ==============================================
/*
104. Maximum Depth of Binary Tree

Учитывая rootбинарное дерево, вернуть его максимальную глубину .

Максимальная глубина бинарного дерева  — 
это количество узлов на самом длинном пути от корневого узла 
до самого дальнего конечного узла.

Пример 1:
Ввод: корень = [3,9,20,ноль,нуль,15,7]
 Вывод: 3

Пример 2:
Ввод: корень = [1, ноль, 2]
 Вывод: 2
 
Ограничения:
Количество узлов в дереве находится в диапазоне .[0, 104]
-100 <= Node.val <= 100
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function (root) {};
// console.log(maxDepth([3, 9, 20, null, null, 15, 7]));
// console.log(maxDepth([1, null, 2]));

//? ==============================================
/*
108. Convert Sorted Array to Binary Search Tree

Дан целочисленный массив, numsв котором элементы отсортированы 
в порядке возрастания , преобразовать его в
сбалансированный по высоте
 бинарное дерево поиска .

Пример 1:
Ввод: nums = [-10,-3,0,5,9]
 Вывод: [0,-3,9,-10,null,5]
 Объяснение: [0,-10,5,null,-3,null ,9] также принимается:

Пример 2:
Ввод: nums = [1,3]
 Вывод: [3,1]
 Объяснение: [1,null,3] и [3,1] — BST со сбалансированной высотой.
 
Ограничения:
1 <= nums.length <= 104
-104 <= nums[i] <= 104
numsсортируется в строго возрастающем порядке.
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var sortedArrayToBST = function (nums) {};
// console.log(sortedArrayToBST([-10, -3, 0, 5, 9]));
// console.log(sortedArrayToBST([1, 3]));

//? ==============================================
/*
110. Balanced Binary Tree

Имея бинарное дерево, определите, является ли оно
сбалансированный по высоте

Пример 1:
Ввод: root = [3,9,20,null,null,15,7]
 Вывод: true

Пример 2:
Ввод: root = [1,2,2,3,3,null,null,4,4]
 Вывод: false

Пример 3:
Ввод: корень = []
 Вывод: правда

Ограничения:
Количество узлов в дереве находится в диапазоне [0, 5000].
-104 <= Node.val <= 104
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function (root) {};
// console.log(isBalanced([3, 9, 20, null, null, 15, 7]));
// console.log(isBalanced([1, 2, 2, 3, 3, null, null, 4, 4]));
// console.log(isBalanced([]));

//? ==============================================
/*
111. Minimum Depth of Binary Tree

Для заданного бинарного дерева найти его минимальную глубину.

Минимальная глубина — это количество узлов на кратчайшем 
пути от корневого узла до ближайшего конечного узла.

Примечание.  Лист — это узел без дочерних элементов.

Пример 1:
Ввод: корень = [3,9,20,ноль,нуль,15,7]
 Вывод: 2

Пример 2:
Ввод: корень = [2, null, 3, null, 4, null, 5, null, 6]
 Вывод: 5 

Ограничения:
Количество узлов в дереве находится в диапазоне .[0, 105]
-1000 <= Node.val <= 1000
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function (root) {};
// console.log(minDepth([3, 9, 20, null, null, 15, 7]));
// console.log(minDepth([2, null, 3, null, 4, null, 5, null, 6]));

//? ==============================================
/*
112. Path Sum

Учитывая rootбинарное дерево и целое число targetSum, вернуть, 
true если дерево имеет путь от корня к листу , 
такой что сумма всех значений на пути равна targetSum.

Лист — это узел без потомков.

Пример 1:
Ввод: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
 Вывод: true
 Объяснение: Путь от корня к листу с целью показана сумма.

Пример 2:
Ввод: root = [1,2,3], targetSum = 5
 Вывод: false
 Объяснение: В дереве есть два пути от корня к листу:
(1 --> 2): сумма равна 3.
(1 --> 3): сумма равна 4.
Не существует пути от корня к листу с суммой = 5.

Пример 3:
Ввод: root = [], targetSum = 0
 Вывод: false
 Объяснение: Поскольку дерево пусто, путей от корня к листу нет.

Ограничения:
Количество узлов в дереве находится в диапазоне [0, 5000].
-1000 <= Node.val <= 1000
-1000 <= targetSum <= 1000
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {boolean}
 */
var hasPathSum = function (root, targetSum) {};
// console.log(hasPathSum([5, 4, 8, 11, null, 13, 4, 7, 2, null, null, null, 1]));
// console.log(hasPathSum([1, 2, 3]));
// console.log(hasPathSum([]));

//? ==============================================
/*
118. Pascal's Triangle

Учитывая целое число numRows, вернуть первые numRows треугольника
Паскаля .

В треугольнике Паскаля каждое число является суммой двух чисел 
непосредственно над ним, как показано:

Пример 1:
Ввод: numRows = 5
 Вывод: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]

Пример 2:
Ввод: numRows = 1
 Вывод: [[1]]

Ограничения:
1 <= numRows <= 30
*/
/**
 * @param {number} numRows
 * @return {number[][]}
 */
var generate = function (numRows) {};
// console.log(generate(5));
// console.log(generate(1));

//? ==============================================
/*
119. Pascal's Triangle II

Учитывая целое число rowIndex, вернуть ( индексированную 0 ) строку 
треугольника Паскаля .rowIndexth

В треугольнике Паскаля каждое число является суммой двух чисел 
непосредственно над ним, как показано: 

Пример 1:
Ввод: rowIndex = 3
 Вывод: [1,3,3,1]

Пример 2:
Ввод: rowIndex = 0
 Вывод: [1]

Пример 3:
Ввод: rowIndex = 1
 Вывод: [1,1]

Ограничения:
0 <= rowIndex <= 33

Дополнение: не могли бы вы оптимизировать свой алгоритм, чтобы использовать только O(rowIndex)дополнительное пространство?
*/
/**
 * @param {number} rowIndex
 * @return {number[]}
 */
var getRow = function (rowIndex) {};
// console.log(getRow(3));
// console.log(getRow(0));
// console.log(getRow(1));

//? ==============================================
/*
121. Best Time to Buy and Sell Stock

Вам дан массив, pricesгде указана prices[i] 
цена данной акции в день.ith

Вы хотите максимизировать свою прибыль, 
выбрав один день для покупки одной акции и выбрав другой день 
в будущем для продажи этой акции.

Верните максимальную прибыль, которую вы можете получить от 
этой сделки . Если вы не можете получить какую-либо прибыль, 
верните 0.

Пример 1:
Входные данные: цены = [7,1,5,3,6,4]
 Выходные данные: 5
 Объяснение: Покупка во 2-й день (цена = 1) и 
 продажа в 5-й день (цена = 6), прибыль = 6-1 = 5.
Обратите внимание, что покупка во 2-й день и продажа в 1-й день 
не разрешены, потому что вы должны купить перед продажей.

Пример 2:
Ввод: цены = [7,6,4,3,1]
 Вывод: 0
 Объяснение: В этом случае транзакции не совершаются и 
 максимальная прибыль = 0. 

Ограничения:
1 <= prices.length <= 105
0 <= prices[i] <= 104
*/
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function (prices) {};
// console.log(maxProfit([7, 1, 5, 3, 6, 4]));
// console.log(maxProfit([7, 6, 4, 3, 1]));

//? ==============================================
/*
125. Valid Palindrome

Фраза является палиндромом , если после преобразования всех 
прописных букв в строчные и удаления всех не буквенно-цифровых 
символов она читается одинаково вперед и назад. Буквенно-цифровые 
символы включают буквы и цифры.

Если задана строка s, возврат, trueесли это палиндром , 
или falseиначе . 

Пример 1:
Ввод: s = "Человек, план, канал: Панама"
 Вывод: true
 Объяснение: "аманапланаканалпанама" - палиндром.

Пример 2:
Ввод: s = "гонка на машине"
 Выход: false
 Объяснение: "гонка на машине" не является палиндромом.

Пример 3:
Ввод: s = " "
 Вывод: true
 Объяснение: s является пустой строкой "" после удаления не 
 буквенно-цифровых символов.
Поскольку пустая строка одинаково читается вперед и назад, 
это палиндром. 

Ограничения:
1 <= s.length <= 2 * 105
sсостоит только из печатных символов ASCII.
*/
/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function (s) {};
// console.log(isPalindrome('A man, a plan, a canal: Panama'));
// console.log(isPalindrome('race a car'));
// console.log(isPalindrome(' '));

//? ==============================================
/*
136. Single Number

Учитывая непустой  массив целых чисел nums, каждый элемент 
встречается дважды , кроме одного. Найди ту единственную.

Вы должны реализовать решение с линейной сложностью времени
выполнения и использовать только постоянное дополнительное 
пространство.

Пример 1:
Ввод: числа = [2,2,1]
 Вывод: 1

Пример 2:
Ввод: числа = [4,1,2,1,2]
 Вывод: 4

Пример 3:
Ввод: число = [1]
 Вывод: 1 

Ограничения:
1 <= nums.length <= 3 * 104
-3 * 104 <= nums[i] <= 3 * 104
Каждый элемент в массиве появляется дважды, за исключением одного элемента, который появляется только один раз.
*/
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function (nums) {};
// console.log(singleNumber([2, 2, 1]));
// console.log(singleNumber([4, 1, 2, 1, 2]));
// console.log(singleNumber([1]));

//? ==============================================
/*
141. Linked List Cycle

Учитывая head, заголовок связанного списка, определите, 
есть ли в связанном списке цикл.

В связанном списке есть цикл, если в списке есть какой-то узел, 
к которому можно снова обратиться, непрерывно следуя  next указателю. Внутри pos используется для обозначения индекса узла, к которому  next подключен указатель хвоста. Обратите внимание, что  pos это не передается как параметр .

Возврат  true, если в связанном списке есть цикл . 
В противном случае возвращайтесь false. 

Пример 1:
Ввод: head = [3,2,0,-4], pos = 1
 Вывод: true
 Объяснение: В связанном списке есть цикл, где хвост 
 соединяется с 1-й вершиной (0-индексированной).

Пример 2:
Ввод: head = [1,2], pos = 0
 Вывод: true
 Объяснение: В связанном списке есть цикл, хвост которого 
 соединяется с 0-й вершиной.

Пример 3:
Ввод: head = [1], pos = -1
 Вывод: false
 Объяснение: В связанном списке нет цикла. 

Ограничения:
Количество узлов в списке находится в диапазоне .[0, 104]
-105 <= Node.val <= 105
pos-1или допустимый индекс в связанном списке. 

Продолжение: можете ли вы решить это, используя O(1)(т.е. постоянную) 
память?
*/
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function (head) {};
// console.log(hasCycle([3, 2, 0, -4])); // pos = 1
// console.log(hasCycle([1, 2])); // pos = 0
// console.log(hasCycle([1])); // pos = -1

//? ==============================================
/*
144. Binary Tree Preorder Traversal

Учитывая rootбинарное дерево, верните предварительный обход значений 
его узлов . 

Пример 1:
Ввод: корень = [1,нуль,2,3]
 Вывод: [1,2,3]

Пример 2:
Ввод: корень = []
 Вывод: []

Пример 3:
Ввод: корень = [1]
 Вывод: [1] 

Ограничения:
Количество узлов в дереве находится в диапазоне [0, 100].
-100 <= Node.val <= 100 

Продолжение: рекурсивное решение тривиально, 
можете ли вы сделать это итеративно?
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function (root) {};
// console.log(preorderTraversal([1, null, 2, 3]));
// console.log(preorderTraversal([]));
// console.log(preorderTraversal([1]));

//? ==============================================
/*
145. Binary Tree Postorder Traversal

Учитывая rootбинарное дерево, вернуть обратный порядок значений 
его узлов . 

Пример 1:
Ввод: корень = [1, ноль, 2,3]
 Вывод: [3,2,1]

Пример 2:
Ввод: корень = []
 Вывод: []

Пример 3:
Ввод: корень = [1]
 Вывод: [1] 

Ограничения:
Количество узлов в дереве находится в диапазоне [0, 100].
-100 <= Node.val <= 100 

Продолжение: рекурсивное решение тривиально, 
можете ли вы сделать это итеративно?
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function (root) {};
// console.log(postorderTraversal([1, null, 2, 3]));
// console.log(postorderTraversal([]));
// console.log(postorderTraversal([1]));

//? ==============================================
/*

*/

//? ==============================================
/*

*/

//? ==============================================
