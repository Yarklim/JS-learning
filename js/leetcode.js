//? ==============================================
/*
69. Sqrt(x)

Учитывая неотрицательное целое число x, вернуть квадратный корень из x округленного вниз 
до ближайшего целого числа . Возвращаемое целое число также должно быть неотрицательным .

Вы не должны использовать какие-либо встроенные экспонентные функции или операторы.

Например, не используйте pow(x, 0.5) в c++ или x ** 0.5 python.
 

Пример 1:
Ввод: x = 4
 Выход: 2
 Объяснение: Квадратный корень из 4 равен 2, поэтому мы возвращаем 2.

Пример 2:
Ввод: x = 8
 Выход: 2
 Объяснение: Квадратный корень из 8 равен 2,82842..., и, 
 поскольку мы округляем его до ближайшего целого числа, возвращается 2.
 
Ограничения:
0 <= x <= 231 - 1
*/
var mySqrt = function (x) {};

// console.log(4);
// console.log(8);
//? ==============================================
/*
88. Merge Sorted Array

Вам даны два массива целых чисел nums1 и nums2, отсортированные в неубывающем порядке, 
и два целых числа m и n, представляющие количество элементов в nums1 и nums2 соответственно.

Объединить nums1 и nums2 в один массив, отсортированный в неубывающем порядке .

Окончательный отсортированный массив не должен возвращаться функцией, 
а должен храниться внутри массива nums1 . Чтобы приспособиться к этому, nums1 имеет длину m + n, 
где первые m элементы обозначают элементы, которые должны быть объединены, 
а последние nэлементы установлены 0 и должны игнорироваться. nums2 имеет длину n.

Пример 1:
Ввод: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
 Вывод: [1,2,2,3,5,6]
 Объяснение: мы объединяем массивы [1,2,3] и [2,5,6].
Результатом слияния является [ 1 , 2 ,2, 3 ,5,6] с подчеркнутыми элементами, 
исходящими из nums1.

Пример 2:
Ввод: nums1 = [1], m = 1, nums2 = [], n = 0
 Вывод: [1]
 Объяснение: Мы объединяем массивы [1] и [].
Результат слияния [1].

Пример 3:
Ввод: nums1 = [0], m = 0, nums2 = [1], n = 1
 Вывод: [1]
 Объяснение: Мы объединяем массивы [] и [1].
Результат слияния [1].
Обратите внимание, что поскольку m = 0, в nums1 нет элементов. 
0 нужен только для того, чтобы результат слияния поместился в nums1.
 
Ограничения:
nums1.length == m + n
nums2.length == n
0 <= m, n <= 200
1 <= m + n <= 200
-109 <= nums1[i], nums2[j] <= 109
 
Дополнение: можете ли вы придумать алгоритм, работающий во O(m + n)времени?
*/
var merge = function (nums1, m, nums2, n) {};

// console.log([1, 2, 3, 0, 0, 0], 3, [2, 5, 6], 3);
// console.log([1], 1, [], 0);
// console.log([0], 0, [1], 1);
//? ==============================================
/*

*/

//? ==============================================
/*

*/

//? ==============================================
/*

*/

//? ==============================================
/*

*/

//? ==============================================

/*
14. Longest Common Prefix

Напишите функцию, которая находит самую длинную строку общего префикса 
среди массива строк.

Если общего префикса нет, вернуть пустую строку "".

Пример 1:

Ввод: strs = ['flower', 'flow', 'flight']
 Вывод: "fl"
Пример 2:

Ввод: strs = ['dog', 'racecar', 'car']
 Вывод: ""
 Объяснение: Среди входных строк нет общего префикса.
 

Ограничения:

1 <= strs.length <= 200
0 <= strs[i].length <= 200
strs[i]состоит только из строчных английских букв.
*/
var longestCommonPrefix = function (strs) {};

// console.log(longestCommonPrefix(['flower', 'flow', 'flight']));
// console.log(longestCommonPrefix(['dog', 'racecar', 'car']));

//? ==============================================
/*
20. Valid Parentheses

Учитывая строку s, содержащую только символы '(', ')', '{', и , 
определите '}', допустима ли входная строка.'['']'

Входная строка действительна, если:

Открытые скобки должны быть закрыты однотипными скобками.
Открытые скобки должны быть закрыты в правильном порядке.
Каждой закрывающей скобке соответствует открытая скобка того же типа.
 

Пример 1:

Ввод: s = "()"
 Вывод: правда
Пример 2:

Ввод: s = "()[]{}"
 Вывод: правда
Пример 3:

Ввод: s = "(]"
 Вывод: ложь
 

Ограничения:

1 <= s.length <= 104
sсостоит только из скобок '()[]{}'.
*/
var isValid = function (s) {};

// console.log(isValid('()'));
// console.log(isValid('()[]{}'));
// console.log(isValid('(]'));
//? ==============================================
/*
67. Add Binary

Учитывая две двоичные строки aи b, верните их сумму в виде двоичной строки .

Пример 1:
Ввод: a = "11", b = "1"
 Выход: "100"

Пример 2:
Ввод: а = "1010", б = "1011"
 Выход: "10101" 

Ограничения:
1 <= a.length, b.length <= 104
aи bсостоят только из '0'или '1'символов.
Каждая строка не содержит ведущих нулей, кроме самого нуля.
*/
var addBinary = function (a, b) {};

// console.log('11', '1');
// console.log('1010', '1011');
//? ==============================================
/*
66. Plus One

Вам дано большое целое число , представленное в виде массива целых чисел digits, 
где каждое число digits[i]является цифрой целого числа. 
Цифры упорядочены от наиболее значащего к наименее значащему в порядке слева направо. 
Большое целое число не содержит начальных символов .ith0

Увеличьте большое целое число на единицу и верните результирующий массив цифр .

Пример 1:
Ввод: цифры = [1,2,3]
 Вывод: [1,2,4]
 Объяснение: Массив представляет целое число 123.
Увеличение на единицу дает 123 + 1 = 124.
Таким образом, результат должен быть [1,2,4].

Пример 2:
Ввод: цифры = [4,3,2,1]
 Вывод: [4,3,2,2]
 Объяснение: Массив представляет целое число 4321.
Увеличение на единицу дает 4321 + 1 = 4322.
Таким образом, результат должен быть [4,3,2,2].

Пример 3:
Ввод: цифры = [9]
 Вывод: [1,0]
 Объяснение: Массив представляет целое число 9.
Увеличение на единицу дает 9 + 1 = 10.
Таким образом, результат должен быть [1,0]. 

Ограничения:
1 <= digits.length <= 100
0 <= digits[i] <= 9
digitsне содержит ведущих 0'.
*/
var plusOne = function (digits) {};

// console.log([1, 2, 3]);
// console.log([4, 3, 2, 1]);
// console.log([9]);
//? ==============================================
/*
58. Length of Last Word

Учитывая строку, sсостоящую из слов и пробелов, вернуть длину последнего слова в строке.

Слово – это максимальное
подстрока
состоящая только из не пробельных символов.

Пример 1:
Ввод: s = "Hello World"
 Вывод: 5
 Объяснение: Последнее слово "World" имеет длину 5.

Пример 2:
Ввод: s = " лети со мной на луну "
 Вывод: 4
 Объяснение: Последнее слово "луна" имеет длину 4.

Пример 3:
Ввод: s = "luffy все еще джойбой"
 Вывод: 6
 Объяснение: Последнее слово "joyboy" имеет длину 6.
 
Ограничения:
1 <= s.length <= 104
sсостоит только из английских букв и пробелов ' '.
В нем будет хотя бы одно слово s.
*/
var lengthOfLastWord = function (s) {};

// console.log('Hello World');
// console.log('   fly me   to   the moon  ');
// console.log('luffy is still joyboy');
//? ==============================================
/*
35. Search Insert Position

Учитывая отсортированный массив различных целых чисел и целевое значение, 
вернуть индекс, если цель найдена. 
Если нет, верните индекс туда, где он был бы, если бы он был вставлен 
по порядку.

Вы должны написать алгоритм со  O(log n) сложностью выполнения.

Пример 1:
Ввод: числа = [1,3,5,6], цель = 5
 Вывод: 2

Пример 2:
Ввод: числа = [1,3,5,6], цель = 2
 Вывод: 1

Пример 3:
Ввод: числа = [1,3,5,6], цель = 7
 Вывод: 4

Ограничения:

1 <= nums.length <= 104
-104 <= nums[i] <= 104
numsсодержит различные значения, отсортированные в порядке возрастания .
-104 <= target <= 104
*/
var searchInsert = function (nums, target) {};

// console.log(searchInsert([1, 3, 5, 6], 5));
// console.log(searchInsert([1, 3, 5, 6], 2));
// console.log(searchInsert([1, 3, 5, 6], 7));
//? ==============================================
