//? ==============================================
/*
20. Valid Parentheses

Учитывая строку s, содержащую только символы '(', ')', '{', и , 
определите '}', допустима ли входная строка.'['']'

Входная строка действительна, если:

Открытые скобки должны быть закрыты однотипными скобками.
Открытые скобки должны быть закрыты в правильном порядке.
Каждой закрывающей скобке соответствует открытая скобка того же типа.
 

Пример 1:

Ввод: s = "()"
 Вывод: правда
Пример 2:

Ввод: s = "()[]{}"
 Вывод: правда
Пример 3:

Ввод: s = "(]"
 Вывод: ложь
 

Ограничения:

1 <= s.length <= 104
s состоит только из скобок '()[]{}'.
*/
// var isValid = function (s) {
//   const brackets = {
//     ')': '(',
//     ']': '[',
//     '}': '{',
// 	};

// 	result = false;

// 	for (let i = 0; i < s.length; i++) {
// 		if (s[i] )
// 	}
// };

// console.log(isValid('()'));
// console.log(isValid('()[]{}'));
// console.log(isValid('(]'));
//? ==============================================
/*
35. Search Insert Position

Учитывая отсортированный массив различных целых чисел и целевое значение, 
вернуть индекс, если цель найдена. 
Если нет, верните индекс туда, где он был бы, если бы он был вставлен 
по порядку.

Вы должны написать алгоритм со  O(log n) сложностью выполнения.

Пример 1:
Ввод: числа = [1,3,5,6], цель = 5
 Вывод: 2

Пример 2:
Ввод: числа = [1,3,5,6], цель = 2
 Вывод: 1

Пример 3:
Ввод: числа = [1,3,5,6], цель = 7
 Вывод: 4

Ограничения:

1 <= nums.length <= 104
-104 <= nums[i] <= 104
numsсодержит различные значения, отсортированные в порядке возрастания .
-104 <= target <= 104
*/
var searchInsert = function (nums, target) {};

// console.log(searchInsert([1, 3, 5, 6], 5));
// console.log(searchInsert([1, 3, 5, 6], 2));
// console.log(searchInsert([1, 3, 5, 6], 7));
//? ==============================================
/*
58. Length of Last Word

Учитывая строку, sсостоящую из слов и пробелов, вернуть длину последнего слова в строке.

Слово – это максимальное
подстрока
состоящая только из не пробельных символов.

Пример 1:
Ввод: s = "Hello World"
 Вывод: 5
 Объяснение: Последнее слово "World" имеет длину 5.

Пример 2:
Ввод: s = " лети со мной на луну "
 Вывод: 4
 Объяснение: Последнее слово "луна" имеет длину 4.

Пример 3:
Ввод: s = "luffy все еще джойбой"
 Вывод: 6
 Объяснение: Последнее слово "joyboy" имеет длину 6.
 
Ограничения:
1 <= s.length <= 104
sсостоит только из английских букв и пробелов ' '.
В нем будет хотя бы одно слово s.
*/
var lengthOfLastWord = function (s) {};

// console.log('Hello World');
// console.log('   fly me   to   the moon  ');
// console.log('luffy is still joyboy');

//? ==============================================
/*
66. Plus One

Вам дано большое целое число , представленное в виде массива целых чисел digits, 
где каждое число digits[i]является цифрой целого числа. 
Цифры упорядочены от наиболее значащего к наименее значащему в порядке слева направо. 
Большое целое число не содержит начальных символов .ith0

Увеличьте большое целое число на единицу и верните результирующий массив цифр .

Пример 1:
Ввод: цифры = [1,2,3]
 Вывод: [1,2,4]
 Объяснение: Массив представляет целое число 123.
Увеличение на единицу дает 123 + 1 = 124.
Таким образом, результат должен быть [1,2,4].

Пример 2:
Ввод: цифры = [4,3,2,1]
 Вывод: [4,3,2,2]
 Объяснение: Массив представляет целое число 4321.
Увеличение на единицу дает 4321 + 1 = 4322.
Таким образом, результат должен быть [4,3,2,2].

Пример 3:
Ввод: цифры = [9]
 Вывод: [1,0]
 Объяснение: Массив представляет целое число 9.
Увеличение на единицу дает 9 + 1 = 10.
Таким образом, результат должен быть [1,0]. 

Ограничения:
1 <= digits.length <= 100
0 <= digits[i] <= 9
digitsне содержит ведущих 0'.
*/
var plusOne = function (digits) {};

// console.log([1, 2, 3]);
// console.log([4, 3, 2, 1]);
// console.log([9]);
//? ==============================================
/*
67. Add Binary

Учитывая две двоичные строки aи b, верните их сумму в виде двоичной строки .

Пример 1:
Ввод: a = "11", b = "1"
 Выход: "100"

Пример 2:
Ввод: а = "1010", б = "1011"
 Выход: "10101" 

Ограничения:
1 <= a.length, b.length <= 104
aи bсостоят только из '0'или '1'символов.
Каждая строка не содержит ведущих нулей, кроме самого нуля.
*/
var addBinary = function (a, b) {};

// console.log('11', '1');
// console.log('1010', '1011');
//? ==============================================

/*
88. Merge Sorted Array

Вам даны два массива целых чисел nums1 и nums2, отсортированные в неубывающем порядке, 
и два целых числа m и n, представляющие количество элементов в nums1 и nums2 соответственно.

Объединить nums1 и nums2 в один массив, отсортированный в неубывающем порядке .

Окончательный отсортированный массив не должен возвращаться функцией, 
а должен храниться внутри массива nums1 . Чтобы приспособиться к этому, nums1 имеет длину m + n, 
где первые m элементы обозначают элементы, которые должны быть объединены, 
а последние nэлементы установлены 0 и должны игнорироваться. nums2 имеет длину n.

Пример 1:
Ввод: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
 Вывод: [1,2,2,3,5,6]
 Объяснение: мы объединяем массивы [1,2,3] и [2,5,6].
Результатом слияния является [ 1 , 2 ,2, 3 ,5,6] с подчеркнутыми элементами, 
исходящими из nums1.

Пример 2:
Ввод: nums1 = [1], m = 1, nums2 = [], n = 0
 Вывод: [1]
 Объяснение: Мы объединяем массивы [1] и [].
Результат слияния [1].

Пример 3:
Ввод: nums1 = [0], m = 0, nums2 = [1], n = 1
 Вывод: [1]
 Объяснение: Мы объединяем массивы [] и [1].
Результат слияния [1].
Обратите внимание, что поскольку m = 0, в nums1 нет элементов. 
0 нужен только для того, чтобы результат слияния поместился в nums1.
 
Ограничения:
nums1.length == m + n
nums2.length == n
0 <= m, n <= 200
1 <= m + n <= 200
-109 <= nums1[i], nums2[j] <= 109
 
Дополнение: можете ли вы придумать алгоритм, работающий во O(m + n)времени?
*/
var merge = function (nums1, m, nums2, n) {};

// console.log((merge[1, 2, 3, 0, 0, 0], 3, [2, 5, 6], 3));
// console.log(merge([1], 1, [], 0));
// console.log((merge[0], 0, [1], 1));
//? ==============================================
/*
94. Binary Tree Inorder Traversal

Учитывая root бинарное дерево, 
вернуть неупорядоченный обход значений его узлов .

Пример 1:
Ввод: корень = [1,нуль,2,3]
 Вывод: [1,3,2]

Пример 2:
Ввод: корень = []
 Вывод: []

Пример 3:
Ввод: корень = [1]
 Вывод: [1]
 
Ограничения:
Количество узлов в дереве находится в диапазоне [0, 100].
-100 <= Node.val <= 100 

Продолжение: рекурсивное решение тривиально, 
можете ли вы сделать это итеративно?
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function (root) {};

// console.log(inorderTraversal([1, null, 2, 3]));
// console.log(inorderTraversal([]));
// console.log(inorderTraversal([1]));

//? ==============================================
/*
100. Same Tree

Имея корни двух бинарных деревьев pи q, напишите функцию, 
проверяющую, совпадают ли они или нет.

Два бинарных дерева считаются одинаковыми, 
если они структурно идентичны, а узлы имеют одинаковое значение.

 Пример 1:
Вход: p = [1,2,3], q = [1,2,3]
 Выход: правда

Пример 2:
Ввод: p = [1,2], q = [1,null,2]
 Вывод: false

Пример 3:
Вход: p = [1,2,1], q = [1,1,2]
 Выход: ложь
 
Ограничения:

Количество узлов в обоих деревьях находится в диапазоне [0, 100].
-104 <= Node.val <= 104
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function (p, q) {};
// console.log(isSameTree([1, 2, 3]));
// console.log(isSameTree([1, 2]));
// console.log(isSameTree([1, 2, 1]));

//? ==============================================
/*
101. Symmetric Tree

Учитывая rootбинарное дерево, проверьте, 
является ли оно зеркалом самого себя 
(т. е. симметричным относительно своего центра).

Пример 1:
Ввод: корень = [1,2,2,3,4,4,3]
 Вывод: правда

Пример 2:
Ввод: root = [1,2,2,null,3,null,3]
 Вывод: false
 
Ограничения:
Количество узлов в дереве находится в диапазоне [1, 1000].
-100 <= Node.val <= 100
 
Дополнение: Могли бы вы решить это как рекурсивно, так и итеративно?
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function (root) {};
// console.log(isSymmetric([1, 2, 2, 3, 4, 4, 3]));
// console.log(isSymmetric([1, 2, 2, null, 3, null, 3]));

//? ==============================================
/*
104. Maximum Depth of Binary Tree

Учитывая rootбинарное дерево, вернуть его максимальную глубину .

Максимальная глубина бинарного дерева  — 
это количество узлов на самом длинном пути от корневого узла 
до самого дальнего конечного узла.

Пример 1:
Ввод: корень = [3,9,20,ноль,нуль,15,7]
 Вывод: 3

Пример 2:
Ввод: корень = [1, ноль, 2]
 Вывод: 2
 
Ограничения:
Количество узлов в дереве находится в диапазоне .[0, 104]
-100 <= Node.val <= 100
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function (root) {};
// console.log(maxDepth([3, 9, 20, null, null, 15, 7]));
// console.log(maxDepth([1, null, 2]));

//? ==============================================
/*
108. Convert Sorted Array to Binary Search Tree

Дан целочисленный массив, numsв котором элементы отсортированы 
в порядке возрастания , преобразовать его в
сбалансированный по высоте
 бинарное дерево поиска .

Пример 1:
Ввод: nums = [-10,-3,0,5,9]
 Вывод: [0,-3,9,-10,null,5]
 Объяснение: [0,-10,5,null,-3,null ,9] также принимается:

Пример 2:
Ввод: nums = [1,3]
 Вывод: [3,1]
 Объяснение: [1,null,3] и [3,1] — BST со сбалансированной высотой.
 
Ограничения:
1 <= nums.length <= 104
-104 <= nums[i] <= 104
numsсортируется в строго возрастающем порядке.
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var sortedArrayToBST = function (nums) {};
// console.log(sortedArrayToBST([-10, -3, 0, 5, 9]));
// console.log(sortedArrayToBST([1, 3]));

//? ==============================================
/*
110. Balanced Binary Tree

Имея бинарное дерево, определите, является ли оно
сбалансированный по высоте

Пример 1:
Ввод: root = [3,9,20,null,null,15,7]
 Вывод: true

Пример 2:
Ввод: root = [1,2,2,3,3,null,null,4,4]
 Вывод: false

Пример 3:
Ввод: корень = []
 Вывод: правда

Ограничения:
Количество узлов в дереве находится в диапазоне [0, 5000].
-104 <= Node.val <= 104
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function (root) {};
// console.log(isBalanced([3, 9, 20, null, null, 15, 7]));
// console.log(isBalanced([1, 2, 2, 3, 3, null, null, 4, 4]));
// console.log(isBalanced([]));

//? ==============================================
/*
111. Minimum Depth of Binary Tree

Для заданного бинарного дерева найти его минимальную глубину.

Минимальная глубина — это количество узлов на кратчайшем 
пути от корневого узла до ближайшего конечного узла.

Примечание.  Лист — это узел без дочерних элементов.

Пример 1:
Ввод: корень = [3,9,20,ноль,нуль,15,7]
 Вывод: 2

Пример 2:
Ввод: корень = [2, null, 3, null, 4, null, 5, null, 6]
 Вывод: 5 

Ограничения:
Количество узлов в дереве находится в диапазоне .[0, 105]
-1000 <= Node.val <= 1000
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function (root) {};
// console.log(minDepth([3, 9, 20, null, null, 15, 7]));
// console.log(minDepth([2, null, 3, null, 4, null, 5, null, 6]));

//? ==============================================
/*
112. Path Sum

Учитывая rootбинарное дерево и целое число targetSum, вернуть, 
true если дерево имеет путь от корня к листу , 
такой что сумма всех значений на пути равна targetSum.

Лист — это узел без потомков.

Пример 1:
Ввод: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
 Вывод: true
 Объяснение: Путь от корня к листу с целью показана сумма.

Пример 2:
Ввод: root = [1,2,3], targetSum = 5
 Вывод: false
 Объяснение: В дереве есть два пути от корня к листу:
(1 --> 2): сумма равна 3.
(1 --> 3): сумма равна 4.
Не существует пути от корня к листу с суммой = 5.

Пример 3:
Ввод: root = [], targetSum = 0
 Вывод: false
 Объяснение: Поскольку дерево пусто, путей от корня к листу нет.

Ограничения:
Количество узлов в дереве находится в диапазоне [0, 5000].
-1000 <= Node.val <= 1000
-1000 <= targetSum <= 1000
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {boolean}
 */
var hasPathSum = function (root, targetSum) {};
// console.log(hasPathSum([5, 4, 8, 11, null, 13, 4, 7, 2, null, null, null, 1]));
// console.log(hasPathSum([1, 2, 3]));
// console.log(hasPathSum([]));

//? ==============================================
/*
118. Pascal's Triangle

Учитывая целое число numRows, вернуть первые numRows треугольника
Паскаля .

В треугольнике Паскаля каждое число является суммой двух чисел 
непосредственно над ним, как показано:

Пример 1:
Ввод: numRows = 5
 Вывод: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]

Пример 2:
Ввод: numRows = 1
 Вывод: [[1]]

Ограничения:
1 <= numRows <= 30
*/
/**
 * @param {number} numRows
 * @return {number[][]}
 */
var generate = function (numRows) {};
// console.log(generate(5));
// console.log(generate(1));

//? ==============================================
/*
119. Pascal's Triangle II

Учитывая целое число rowIndex, вернуть ( индексированную 0 ) строку 
треугольника Паскаля .rowIndexth

В треугольнике Паскаля каждое число является суммой двух чисел 
непосредственно над ним, как показано: 

Пример 1:
Ввод: rowIndex = 3
 Вывод: [1,3,3,1]

Пример 2:
Ввод: rowIndex = 0
 Вывод: [1]

Пример 3:
Ввод: rowIndex = 1
 Вывод: [1,1]

Ограничения:
0 <= rowIndex <= 33

Дополнение: не могли бы вы оптимизировать свой алгоритм, чтобы использовать только O(rowIndex)дополнительное пространство?
*/
/**
 * @param {number} rowIndex
 * @return {number[]}
 */
var getRow = function (rowIndex) {};
// console.log(getRow(3));
// console.log(getRow(0));
// console.log(getRow(1));

//? ==============================================
/*
121. Best Time to Buy and Sell Stock

Вам дан массив, pricesгде указана prices[i] 
цена данной акции в день.ith

Вы хотите максимизировать свою прибыль, 
выбрав один день для покупки одной акции и выбрав другой день 
в будущем для продажи этой акции.

Верните максимальную прибыль, которую вы можете получить от 
этой сделки . Если вы не можете получить какую-либо прибыль, 
верните 0.

Пример 1:
Входные данные: цены = [7,1,5,3,6,4]
 Выходные данные: 5
 Объяснение: Покупка во 2-й день (цена = 1) и 
 продажа в 5-й день (цена = 6), прибыль = 6-1 = 5.
Обратите внимание, что покупка во 2-й день и продажа в 1-й день 
не разрешены, потому что вы должны купить перед продажей.

Пример 2:
Ввод: цены = [7,6,4,3,1]
 Вывод: 0
 Объяснение: В этом случае транзакции не совершаются и 
 максимальная прибыль = 0. 

Ограничения:
1 <= prices.length <= 105
0 <= prices[i] <= 104
*/
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function (prices) {};
// console.log(maxProfit([7, 1, 5, 3, 6, 4]));
// console.log(maxProfit([7, 6, 4, 3, 1]));

//? ==============================================
/*
125. Valid Palindrome

Фраза является палиндромом , если после преобразования всех 
прописных букв в строчные и удаления всех не буквенно-цифровых 
символов она читается одинаково вперед и назад. Буквенно-цифровые 
символы включают буквы и цифры.

Если задана строка s, возврат, trueесли это палиндром , 
или falseиначе . 

Пример 1:
Ввод: s = "Человек, план, канал: Панама"
 Вывод: true
 Объяснение: "аманапланаканалпанама" - палиндром.

Пример 2:
Ввод: s = "гонка на машине"
 Выход: false
 Объяснение: "гонка на машине" не является палиндромом.

Пример 3:
Ввод: s = " "
 Вывод: true
 Объяснение: s является пустой строкой "" после удаления не 
 буквенно-цифровых символов.
Поскольку пустая строка одинаково читается вперед и назад, 
это палиндром. 

Ограничения:
1 <= s.length <= 2 * 105
sсостоит только из печатных символов ASCII.
*/
/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function (s) {};
// console.log(isPalindrome('A man, a plan, a canal: Panama'));
// console.log(isPalindrome('race a car'));
// console.log(isPalindrome(' '));

//? ==============================================
/*
136. Single Number

Учитывая непустой  массив целых чисел nums, каждый элемент 
встречается дважды , кроме одного. Найди ту единственную.

Вы должны реализовать решение с линейной сложностью времени
выполнения и использовать только постоянное дополнительное 
пространство.

Пример 1:
Ввод: числа = [2,2,1]
 Вывод: 1

Пример 2:
Ввод: числа = [4,1,2,1,2]
 Вывод: 4

Пример 3:
Ввод: число = [1]
 Вывод: 1 

Ограничения:
1 <= nums.length <= 3 * 104
-3 * 104 <= nums[i] <= 3 * 104
Каждый элемент в массиве появляется дважды, за исключением одного элемента, который появляется только один раз.
*/
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function (nums) {};
// console.log(singleNumber([2, 2, 1]));
// console.log(singleNumber([4, 1, 2, 1, 2]));
// console.log(singleNumber([1]));

//? ==============================================
/*
141. Linked List Cycle

Учитывая head, заголовок связанного списка, определите, 
есть ли в связанном списке цикл.

В связанном списке есть цикл, если в списке есть какой-то узел, 
к которому можно снова обратиться, непрерывно следуя  next указателю. Внутри pos используется для обозначения индекса узла, к которому  next подключен указатель хвоста. Обратите внимание, что  pos это не передается как параметр .

Возврат  true, если в связанном списке есть цикл . 
В противном случае возвращайтесь false. 

Пример 1:
Ввод: head = [3,2,0,-4], pos = 1
 Вывод: true
 Объяснение: В связанном списке есть цикл, где хвост 
 соединяется с 1-й вершиной (0-индексированной).

Пример 2:
Ввод: head = [1,2], pos = 0
 Вывод: true
 Объяснение: В связанном списке есть цикл, хвост которого 
 соединяется с 0-й вершиной.

Пример 3:
Ввод: head = [1], pos = -1
 Вывод: false
 Объяснение: В связанном списке нет цикла. 

Ограничения:
Количество узлов в списке находится в диапазоне .[0, 104]
-105 <= Node.val <= 105
pos-1или допустимый индекс в связанном списке. 

Продолжение: можете ли вы решить это, используя O(1)(т.е. постоянную) 
память?
*/
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function (head) {};
// console.log(hasCycle([3, 2, 0, -4])); // pos = 1
// console.log(hasCycle([1, 2])); // pos = 0
// console.log(hasCycle([1])); // pos = -1

//? ==============================================
/*
144. Binary Tree Preorder Traversal

Учитывая rootбинарное дерево, верните предварительный обход значений 
его узлов . 

Пример 1:
Ввод: корень = [1,нуль,2,3]
 Вывод: [1,2,3]

Пример 2:
Ввод: корень = []
 Вывод: []

Пример 3:
Ввод: корень = [1]
 Вывод: [1] 

Ограничения:
Количество узлов в дереве находится в диапазоне [0, 100].
-100 <= Node.val <= 100 

Продолжение: рекурсивное решение тривиально, 
можете ли вы сделать это итеративно?
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function (root) {};
// console.log(preorderTraversal([1, null, 2, 3]));
// console.log(preorderTraversal([]));
// console.log(preorderTraversal([1]));

//? ==============================================
/*
145. Binary Tree Postorder Traversal

Учитывая rootбинарное дерево, вернуть обратный порядок значений 
его узлов . 

Пример 1:
Ввод: корень = [1, ноль, 2,3]
 Вывод: [3,2,1]

Пример 2:
Ввод: корень = []
 Вывод: []

Пример 3:
Ввод: корень = [1]
 Вывод: [1] 

Ограничения:
Количество узлов в дереве находится в диапазоне [0, 100].
-100 <= Node.val <= 100 

Продолжение: рекурсивное решение тривиально, 
можете ли вы сделать это итеративно?
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function (root) {};
// console.log(postorderTraversal([1, null, 2, 3]));
// console.log(postorderTraversal([]));
// console.log(postorderTraversal([1]));

//? ==============================================
/*

*/

//? ==============================================
/*

*/

//? ==============================================
