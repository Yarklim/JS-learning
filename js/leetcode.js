//? ==============================================
/*
70 - Climbing Stairs

Вы поднимаетесь по лестнице. 
Требуется nнесколько шагов, чтобы достичь вершины.

Каждый раз можно либо подняться 1, либо 2 сделать шаг. 
Сколькими различными способами вы можете подняться на вершину?
Пример 1:
Вход: n = 2
 Выход: 2
 Объяснение: Есть два способа взобраться на вершину.
1. 1 шаг + 1 шаг
2. 2 шага

Пример 2:
Вход: n = 3
 Выход: 3
 Объяснение: Есть три способа подняться на вершину.
1. 1 шаг + 1 шаг + 1 шаг
2. 1 шаг + 2 шага
3. 2 шага + 1 шаг

Ограничения:
1 <= n <= 45
*/
var climbStairs = function (n) {};

// console.log(climbStairs(2));
// console.log(climbStairs(3));
//? ==============================================
/*

*/

//? ==============================================
/*
13. Roman to Integer

Римские цифры представлены семью различными символами:  I, V, X, L, и .CDM

Символ        Значение
I 1
V 5
Х 10
L 50
С 100
D 500
М 1000
Например, 2 пишется как II римскими цифрами, просто две сложенные вместе. 
12 пишется как  XII, что просто X + II. 
Число 27записывается как XXVII, то есть XX + V + II.

Римские цифры обычно пишутся слева направо от большего к меньшему. 
Однако цифра «четыре» — не IIII. 
Вместо этого цифра четыре записывается как IV. 
Так как единица предшествует пятерке, мы вычитаем ее и получаем четыре. 
Тот же принцип применим к числу девять, которое записывается как IX. 
Есть шесть случаев, когда используется вычитание:

I можно поставить перед V(5) и X(10), чтобы получилось 4 и 9. 
X можно поставить перед L(50) и C(100), чтобы получилось 40 и 90. 
C можно поставить перед D(500) и M(1000), чтобы получить 400 и 900.

Дана римская цифра, преобразовать ее в целое число.

Пример 1:

Ввод: s = "III"
 Вывод: 3
 Объяснение: III = 3.

Пример 2:

Вход: s = "LVIII"
 Выход: 58
 Объяснение: L = 50, V = 5, III = 3.

Пример 3:

Ввод: s = "MCMXCIV"
 Вывод: 1994
 Объяснение: M = 1000, CM = 900, XC = 90 и IV = 4.
 

Ограничения:

1 <= s.length <= 15
s содержит только символы ('I', 'V', 'X', 'L', 'C', 'D', 'M').
Гарантируется , что s это допустимая римская цифра в диапазоне [1, 3999].
*/
var romanToInt = function (s) {};

// console.log(romanToInt('III'));
// console.log(romanToInt('LVIII'));
// console.log(romanToInt('MCMXCIV'));
//? ==============================================
/*
14. Longest Common Prefix

Напишите функцию, которая находит самую длинную строку общего префикса 
среди массива строк.

Если общего префикса нет, вернуть пустую строку "".

Пример 1:

Ввод: strs = ["цветок","поток","полет"]
 Вывод: "fl"
Пример 2:

Ввод: strs = ["собака","гоночная машина","машина"]
 Вывод: ""
 Объяснение: Среди входных строк нет общего префикса.
 

Ограничения:

1 <= strs.length <= 200
0 <= strs[i].length <= 200
strs[i]состоит только из строчных английских букв.
*/
var longestCommonPrefix = function (strs) {};

// console.log(longestCommonPrefix(['flower', 'flow', 'flight']));
// console.log(longestCommonPrefix(['dog', 'racecar', 'car']));

//? ==============================================
/*
20. Valid Parentheses

Учитывая строку s, содержащую только символы '(', ')', '{', и , 
определите '}', допустима ли входная строка.'['']'

Входная строка действительна, если:

Открытые скобки должны быть закрыты однотипными скобками.
Открытые скобки должны быть закрыты в правильном порядке.
Каждой закрывающей скобке соответствует открытая скобка того же типа.
 

Пример 1:

Ввод: s = "()"
 Вывод: правда
Пример 2:

Ввод: s = "()[]{}"
 Вывод: правда
Пример 3:

Ввод: s = "(]"
 Вывод: ложь
 

Ограничения:

1 <= s.length <= 104
sсостоит только из скобок '()[]{}'.
*/
var isValid = function (s) {};

// console.log(isValid('()'));
// console.log(isValid('()[]{}'));
// console.log(isValid('(]'));
//? ==============================================
/*
21. Merge Two Sorted Lists

Вам даны главы двух отсортированных связанных списков list1и list2.

Объедините два списка в один отсортированный список. 
Список должен быть составлен путем соединения узлов первых двух списков.

Возвращает заголовок объединенного связанного списка .

Пример 1:

Ввод: список1 = [1,2,4], список2 = [1,3,4]
 Вывод: [1,1,2,3,4,4]

Пример 2:

Ввод: список1 = [], список2 = []
 Вывод: []

Пример 3:

Ввод: список1 = [], список2 = [0]
 Выход: [0]

Ограничения:

Количество узлов в обоих списках находится в диапазоне [0, 50].
-100 <= Node.val <= 100
Оба list1и list2отсортированы в неубывающем порядке.
*/
/**
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 */
var mergeTwoLists = function (list1, list2) {};

// console.log(mergeTwoLists([1, 2, 4], [1, 3, 4]));
// console.log(mergeTwoLists([], []));
// console.log(mergeTwoLists([], [0]));
//? ==============================================
/*
26. Remove Duplicates from Sorted Array

Учитывая целочисленный массив nums, отсортированный в неубывающем порядке, 
удалите дубликаты на месте , чтобы каждый уникальный элемент 
появлялся только один раз . 
Относительный порядок элементов должен быть сохранен .

Поскольку в некоторых языках невозможно изменить длину массива, 
вместо этого вы должны поместить результат в первую часть массива nums. 
Более формально, если есть kэлементы после удаления дубликатов, 
то первые kэлементы nums должны содержать окончательный результат. 
Неважно, что вы оставите за пределами первых  k элементов.

Возврат kпосле размещения конечного результата в первых kслотахnums .

Не выделяйте дополнительное пространство для другого массива.
Вы должны сделать это, изменив входной массив на месте с дополнительной 
памятью O (1).

Пользовательский судья:

Судья проверит ваше решение с помощью следующего кода:

int[] числа = [...]; // Входной массив
int[] ожидаемые числа = [...]; // Ожидаемый ответ правильной длины

int k = удалить дубликаты (числа); // Вызывает вашу реализацию

утверждать k == ожидаемоеNums.length;
for (int i = 0; i < k; i++) {
    утверждать nums[i] == ожидаемоеNums[i];
}
Если все утверждения пройдены, то ваше решение будет принято .

 

Пример 1:

Ввод: nums = [1,1,2]
 Вывод: 2, nums = [1,2,_]
 Объяснение: Ваша функция должна возвращать k = 2, 
 причем первые два элемента nums равны 1 и 2 соответственно.
Неважно, что вы оставляете за возвращенным k 
(следовательно, это символы подчеркивания).
Пример 2:

Ввод: числа = [0,0,1,1,1,2,2,3,3,4]
 Выход: 5, числа = [0,1,2,3,4,_,_,_,_, _]
 Объяснение: Ваша функция должна возвращать k = 5, 
 причем первые пять элементов nums равны 0, 1, 2, 3 и 4 соответственно.
Неважно, что вы оставляете за возвращенным k 
(следовательно, это символы подчеркивания).

Ограничения:

1 <= nums.length <= 3 * 104
-100 <= nums[i] <= 100
numsсортируется в порядке неубывания .
*/
var removeDuplicates = function (nums) {};

// console.log(removeDuplicates([1, 1, 2]));
// console.log(removeDuplicates([0, 0, 1, 1, 1, 2, 2, 3, 3, 4]));
//? ==============================================
/*
27. Remove Element
Учитывая целочисленный массив numsи целое число val, 
удалите все вхождения valin nums in-place . 
Относительный порядок элементов может быть изменен.

Поскольку в некоторых языках невозможно изменить длину массива, 
вместо этого вы должны поместить результат в первую часть массива nums. 
Более формально, если есть kэлементы после удаления дубликатов, 
то первые kэлементы numsдолжны содержать окончательный результат. 
Неважно, что вы оставите за пределами первых kэлементов.

Возврат kпосле размещения конечного результата в первых kслотахnums .

Не выделяйте дополнительное пространство для другого массива. 
Вы должны сделать это, изменив входной массив на месте с дополнительной 
памятью O (1).

Пользовательский судья:

Судья проверит ваше решение с помощью следующего кода:

int[] числа = [...]; // Входной массив
интервал = ...; // Значение для удаления
int[] ожидаемые числа = [...]; // Ожидаемый ответ правильной длины.
                            // Он отсортирован без значений, равных val.

int k = removeElement (числа, значения); // Вызывает вашу реализацию

утверждать k == ожидаемоеNums.length;
сортировать (числа, 0, к); // Сортируем первые k элементов nums
for (int я = 0; я <фактическая длина; я ++) {
    утверждать nums[i] == ожидаемоеNums[i];
}
Если все утверждения пройдены, то ваше решение будет принято .

 

Пример 1:

Ввод: nums = [3,2,2,3], val = 3
 Вывод: 2, nums = [2,2,_,_]
 Объяснение: Ваша функция должна возвращать k = 2, 
 причем первые два элемента nums равны 2.
Неважно, что вы оставляете за возвращенным k 
(следовательно, это символы подчеркивания).
Пример 2:

Ввод: nums = [0,1,2,2,3,0,4,2], val = 2
 Выход: 5, nums = [0,1,4,0,3,_,_,_]
 Объяснение: Ваша функция должна возвращать k = 5, 
 причем первые пять элементов nums содержат 0, 0, 1, 3 и 4.
Обратите внимание, что пять элементов могут быть возвращены в любом порядке.
Неважно, что вы оставляете за возвращенным k 
(следовательно, это символы подчеркивания).
 

Ограничения:

0 <= nums.length <= 100
0 <= nums[i] <= 50
0 <= val <= 100
*/
var removeElement = function (nums, val) {};

// console.log(removeElement([3, 2, 2, 3], 3));
// console.log(removeElement([0, 1, 2, 2, 3, 0, 4, 2], 2));
//? ==============================================
/*
35. Search Insert Position

Учитывая отсортированный массив различных целых чисел и целевое значение, 
вернуть индекс, если цель найдена. 
Если нет, верните индекс туда, где он был бы, если бы он был вставлен 
по порядку.

Вы должны написать алгоритм со  O(log n)сложностью выполнения.

Пример 1:

Ввод: числа = [1,3,5,6], цель = 5
 Вывод: 2
Пример 2:

Ввод: числа = [1,3,5,6], цель = 2
 Вывод: 1
Пример 3:

Ввод: числа = [1,3,5,6], цель = 7
 Вывод: 4

Ограничения:

1 <= nums.length <= 104
-104 <= nums[i] <= 104
numsсодержит различные значения, отсортированные в порядке возрастания .
-104 <= target <= 104
*/
var searchInsert = function (nums, target) {};

// console.log(searchInsert([1, 3, 5, 6], 5));
// console.log(searchInsert([1, 3, 5, 6], 2));
// console.log(searchInsert([1, 3, 5, 6], 7));
//? ==============================================
