//? ============ Синтаксис spread и rest ===========
/*
? -------- spread: передача аргументов --------
Операция ... (spread) позволяет распылить коллекцию элементов (массив, строку или объект) в место, где ожидается набор отдельных значений.
Конечно есть некоторые ограничения, например нельзя распылить массив в объект и наоборот.
В JavaScript распыление не изменяет оригинальную коллекцию, то есть делается копия каждого элемента.
*/
//? Например, метод Math.max(аргументы) ищет и возвращает самый большой из аргументов(чисел),
//? то есть ожидает не массив значений, а произвольное количество аргументов.

const temps = [14, -4, 25, 8, 11];

// В консоли будет массив
console.log(temps);
// ❌ Так не сработает, потому что передаём целый массив
console.log(Math.max(temps)); // NaN

// В консоли будет набор отдельных чисел
console.log(...temps);
// ✅ Распылим коллекцию элементов как отдельные аргументы
console.log(Math.max(...temps)); // 25

// То есть запись Math.max(...[14, -4, 25, 8, 11]),
// после интерпретации превращается в Math.max(14, -4, 25, 8, 11) - синтаксис ... возвращает распакованный массив,
// то есть распыляет его элементы как отдельные аргументы.

/*
? --------- spread: создание нового массива ------
Операция ... (spread) позволяет создать копию массива или «склеить» произвольное количество массивов в один новый.
Раньше для этого использовали методы slice() и concat(), но операция распыления позволяет сделать тоже самое в более краткой форме.
*/
const temps2 = [14, -4, 25, 8, 11];

// Это точная, но независимая копия массива temps
const copyOfTemps = [...temps2];
console.log(copyOfTemps); // [14, -4, 25, 8, 11]

// В примере выше у нас есть ящик яблок temps и мы хотим сделать его точную копию.
// Берём пустой ящик и пересыпаем в него яблоки из исходного ящика temps - распыляем его в другую коллекцию.
// При этом ящик temps не изменится, в нём все ещё будут яблоки, а в новом ящике - их точные копии.

// В следующем примере мы ссыпаем яблоки из двух ящиков в один новый.
// Оригинальные ящики(массивы) не изменятся, а в новом будут копии всех их яблок(элементов).
// Порядок распыления важен - он влияет на порядок элементов в новой коллекции.

const lastWeekTemps = [14, 25, 11];
const currentWeekTemps = [23, 17, 18];
const allTemps = [...lastWeekTemps, ...currentWeekTemps];
console.log(allTemps); // [14, 25, 11, 23, 17, 18]

/*
? spread: создание нового объекта
Операция ... (spread) позволяет распылить свойства произвольного количества объектов в один новый.
*/

// Распыление объекта (старый метод):
const a = { x: 1, y: 2 };
const b = { x: 0, z: 3 };

const c = Object.assign({}, a, b);
console.log(c); // {x: 0, y: 2, z: 3}

// Распыление объекта в современном синтаксисе:
const first1 = { propA: 5, propB: 10 };
const second1 = { propC: 15 };
const third1 = { ...first1, ...second1 };
console.log(third1); // { propA: 5, propB: 10, propC: 15 }

// Порядок распыления имеет значение. Имена свойств объекта уникальные, поэтому свойства распыляемого объекта
// могут перезаписать значение уже существующего свойства, если их имена совпадают.

const first2 = { propA: 5, propB: 10, propC: 50 };
const second2 = { propC: 15, propD: 20 };

const third2 = { ...first2, ...second2 };
console.log(third); // { propA: 5, propB: 10, propC: 15, propD: 20 }

const fourth2 = { ...second2, ...first2 };
console.log(fourth2); // { propA: 5, propB: 10, propC: 50, propD: 20 }

// Во время распыления можно добавлять свойства в произвольное место.
// Главное помнить про уникальность имени свойства и о том, что его значение может быть перезаписано.

const first3 = { propA: 5, propB: 10, propC: 50 };
const second3 = { propC: 15 };

const third3 = { propB: 20, ...first3, ...second2 };
console.log(third3); // { propA: 5, propB: 10, propC: 15 }

const fourth3 = { ...first3, ...second3, propB: 20 };
console.log(fourth3); // { propA: 5, propB: 20, propC: 15 }

const fifth3 = { ...first3, propB: 20, ...second3 };
console.log(fifth3); // { propA: 5, propB: 20, propC: 15 }

/*
? -------- rest: сбор всех аргументов функции ---------
Операция ... (rest) позволяет собрать группу независимых элементов в новую коллекцию. 
Синтаксически это близнец операции распыления, но отличить их просто - распыление это когда ... находится в правой части операции присваивания, а сбор это когда ... находится в её левой части.
Одна из областей применения операции rest это создание функций которые могут принимать произвольное количество аргументов.
*/

// Как объявить параметры функции так,
// чтобы можно было передать любое кол-во аргументов?
function multiply() {
  // ...
}
multiply(1, 2);
multiply(1, 2, 3);
multiply(1, 2, 3, 4);

// Если убрать весь «синтаксический шум» и посмотреть на аргументы и параметры функции, то аргументы находятся в правой части операции присваивания, а параметры в левой, потому что значения аргументов присваиваются объявленным параметрам.
// Значит можно «собрать» все аргументы функции в один параметр используя операцию rest.

function multiply(...args) {
  console.log(args); // массив всех аргументов
}

multiply(1, 2);
multiply(1, 2, 3);
multiply(1, 2, 3, 4);

// Имя параметра может быть произвольным.
// Чаще всего его называют args, restArgs или otherArgs, сокращённое от arguments.

//? -------- rest: сбор части аргументов функции ----------
// Операция ... (rest) также позволяет собрать в массив только ту часть аргументов, которая необходима, объявив параметры до «сбора».

function multiply(firstNumber, secondNumber, ...otherArgs) {
  console.log(firstNumber); // Значение первого аргумента
  console.log(secondNumber); // Значение второго аргумента
  console.log(otherArgs); // Массив остальных аргументов
}

multiply(1, 2);
multiply(1, 2, 3);
multiply(1, 2, 3, 4);

// Все агументы, для которых будут объявлены параметры, передадут им свои значения, остальные аргументы будут помещены в массив.
// Операция rest собирает все оставшиеся аргументы и поэтому должна идти последней в подписи функции, иначе будет ошибка.

/*
? ============ Деструктуризация объектов =========

При разработке программ данные приходят, как правило, в виде массивов и объектов, значения которых необходимо записать в локальные переменные. 
Для того, чтобы делать это максимально просто, в современном стандарте есть синтаксис деструктуризирующего присваивания.
Сложные данные всегда представлены объектом. 
Множественные обращения к свойствам объекта визуально загрязняют код.
*/

const book10 = {
  title: 'The Last Kingdom',
  author: 'Bernard Cornwell',
  genres: ['historical prose', 'adventure'],
  isPublic: true,
  rating: 8.38,
};

const accessType1 = book10.isPublic ? 'публичном' : 'закрытом';
const message1 = `Книга ${book10.title} автора ${book10.author} с рейтингом ${book10.rating} находится в ${accessType1} доступе.`;

// Деструктуризация позволяет «распаковать» значения свойств объекта в локальные переменные.
// Это делает код в месте их использования менее «шумным».

const book11 = {
  title: 'The Last Kingdom',
  author: 'Bernard Cornwell',
  genres: ['historical prose', 'adventure'],
  isPublic: true,
  rating: 8.38,
};

// Деструктуризируем
const { title, author, isPublic, rating, coverImage } = book11;
console.log(coverImage); // undefined

const accessType2 = isPublic ? 'публичном' : 'закрытом';
const message2 = `Книга ${title} автора ${author} с рейтингом ${rating} находится в ${accessType2} доступе.`;

// Деструктуризация всегда находится в левой части операции присвоения.
// Переменным внутри фигурных скобок присваиваются значения свойств объекта.
// Если имя переменной и имя свойства совпадают, то происходит присваивание, в противном случае ей будет присвоено undefined.
// Порядок объявления переменных в фигурных скобках не важен.

//? Изменение имени переменной
// При деструктуризации можно изменить имя переменной в которую распаковывается значение свойства.
// Сначала пишем имя свойства из которого хотим получить значение, после чего ставим двоеточие и пишем имя переменной в которую необходимо поместить значение этого свойства.

const firstBook = {
  title: 'The Last Kingdom',
  coverImage:
    'https://images-na.ssl-images-amazon.com/images/I/51b5YG6Y1rL.jpg',
};

const {
  title: firstTitle,
  coverImage: firstCoverImage = 'https://via.placeholder.com/640/480',
} = firstBook;

console.log(firstTitle); // The Last Kingdom
console.log(firstCoverImage); // https://images-na.ssl-images-amazon.com/images/I/51b5YG6Y1rL.jpg

const secondBook = {
  title: 'Сон смешного человека',
};

const {
  title: secondTitle,
  coverImage: secondCoverImage = 'https://via.placeholder.com/640/480',
} = secondBook;

console.log(secondTitle); // Сон смешного человека
console.log(secondCoverImage); // https://via.placeholder.com/640/480

// Такая запись читается как «Создать переменную firstTitle, в которую поместить значение свойства title из объекта firstBook» и т. д.

//? --------- Деструктуризация в циклах ---------
// При переборе массива объектов циклом for...of получаеются множественные обращения к свойствам объекта.

const books = [
  {
    title: 'The Last Kingdom',
    author: 'Bernard Cornwell',
    rating: 8.38,
  },
  {
    title: 'На берегу спокойных вод',
    author: 'Роберт Шекли',
    rating: 8.51,
  },
];

for (const book of books) {
  console.log(book.title);
  console.log(book.author);
  console.log(book.rating);
}

// Для того чтобы сократить количество повторений можно деструктуризировать свойства объекта в локальные переменные в теле цикла.

for (const book of books) {
  const { title, author, rating } = book;

  console.log(title);
  console.log(author);
  console.log(rating);
}

// Если в объекте немного свойств, деструктуризацию можно выполнить прямо в месте объявления переменной book.

for (const { title, author, rating } of books) {
  console.log(title);
  console.log(author);
  console.log(rating);
}

//? ---------- Глубокая деструктуризация ------------
// Для деструктуризации свойств вложенных объектов используются те же принципы, что и в трёх предыдущих упражнениях.

const user = {
  name: 'Jacques Gluke',
  tag: 'jgluke',
  stats: {
    followers: 5603,
    views: 4827,
    likes: 1308,
  },
};

const {
  name,
  tag,
  stats: { followers, views: userViews, likes: userLikes = 0 },
} = user;

console.log(name); // Jacques Gluke
console.log(tag); // jgluke
console.log(followers); // 5603
console.log(userViews); // 4827
console.log(userLikes); // 1308

/*
? ========== Деструктуризация массивов ==========
Деструктуризирующее присваивание можно использовать и для массивов, но с некоторыми особенностями.
Вместо фигурных скобок {} используются квадратные [].
Переменным, указанным в квадратных скобках [], будут последовательно присваиваться значения элементов массива.
Например, есть массив цветов из которого нужно в отдельные переменные получить значения каждой составляющей цвета.
*/

const rgb1 = [200, 255, 100];
const [red1, green1, blue1] = rgb1;

console.log(`R:${red1},G:${green1},B:${blue1}`); // "R:200,G:255,B:100"

// После ключевого слова const или let ставим открывающую и закрывающую квадратные скобки, как при объявлении массива.
// Внутри скобок, через запятую, указываем имена переменных, в которые будут помещены значения массива.

// В результате такой записи будут созданы 3 переменные и в них будут помещены элементы в нумерованном порядке - от 0 и до конца массива.

// При деструктуризации массивов, значение переменной может быть присвоено после ее объявления.
// На практике это используется редко.

const rgb2 = [200, 255, 100];
let red2, green2, blue2;

[red2, green2, blue2] = rgb2;

console.log(`R:${red2},G:${green2},B:${blue2}`); // "R:200,G:255,B:100"

// Если переменных больше чем элементов массива, им будет присвоено undefined, поэтому можно указывать значения по умолчанию.

const rgb3 = [200, 100, 255];

const [red3, green3, blue3, alfa3 = 0.3] = rgb3;

console.log(`R:${red3},G:${green3},B:${blue3},Alfa:${alfa3}`); // "R:200,G:100,B:255,Alfa:0.3"

// Иногда из массива необходимо деструктуризировать только первые N элементов, а остальные сохранить в одну переменную в виде массива.
// При деструкции массива можно распаковать и присвоить оставшуюся часть элементов массива переменной, используя операцию ... (rest).

const rgb4 = [200, 255, 100];

const [red4, ...colors] = rgb4;

console.log(red4); // "200"
console.log(colors); // [255, 100]

// Элементы можно пропускать.
// Допустим, из массива rgb необходимо взять только последнее значение.
// На практике эта возможность используется редко.

const rgb5 = [200, 100, 255];

const [, , blue5] = rgb5;

console.log(`Blue: ${blue5}`); // "Blue: 255"

/*
? ============ Паттерн «Объект параметров» ============
Если функция принимает более двух - трёх аргументов, очень просто запутаться в какой последовательности что передавать. 
В результате получается очень неочевидный код в месте её вызова.
*/

function doStuffWithBook(title, numberOfPages, downloads, rating, public) {
  // Делаем что-то с параметрами
  console.log(title);
  console.log(numberOfPages);
  // И так далее
}

// ❌ Что такое 736? Что такое 10283? Что такое true?
doStuffWithBook('The Last Kingdom', 736, 10283, 8.38, true);

// Паттерн «Объект параметров» помогает решить эту проблему, заменяя набор параметров всего одним - объектом с именованными свойствами.

function doStuffWithBook(book) {
  // Делаем что-то со свойствами объекта
  console.log(book.title);
  console.log(book.numberOfPages);
  // И так далее
}

// Тогда во время её вызова передаём один объект с необходимыми свойствами.

// ✅ Всё понятно
doStuffWithBook({
  title: 'The Last Kingdom',
  numberOfPages: 736,
  downloads: 10283,
  rating: 8.38,
  isPublic: true,
});

// Ещё один плюс в том, что можно деструктуризировать объект в параметре book.
// Это можно сделать в теле функции.

function doStuffWithBook(book) {
  const { title, numberOfPages, downloads, rating, isPublic } = book;
  console.log(title);
  console.log(numberOfPages);
  // И так далее
}

// Или сразу в сигнатуре (подписи) функции, разницы нет.

function doStuffWithBook({
  title,
  numberOfPages,
  downloads,
  rating,
  isPublic,
}) {
  console.log(title);
  console.log(numberOfPages);
  // И так далее
}
