//? ============== Контекст выполнения функции ================

// Можно с уверенностью сказать, что ключевое слово this это одна из самых запутанных концепций JavaScript на старте обучения.
// Новички часто подставляют this методом научного тыка до тех пор, пока скрипт не сработает.

// Контекст в JavaScript похож на контекст в предложении:

// Петя бежит быстро, потому что Петя пытается поймать поезд.
// Петя бежит быстро, потому что он пытается поймать поезд.
// Второе предложение звучит лаконичнее.Предметом предложения является Петя и мы можем сказать, что контекст предложения - это Петя,
// потому что он в центре внимания в это конкретное время в предложении.Даже местоимение «кто» относится к Пете.

// И точно так же объект может быть текущим контекстом исполнения функции.

// Петя бежит быстро, потому что Петя пытается поймать поезд.
const petya1 = {
  username: 'Petya',
  showName() {
    console.log(petya1.username);
  },
};

petya1.showName();

// Обращение к свойствам объекта внутри методов, используя имя самого объекта, аналогично использованию Петя вместо он.

// Внутри функций можно использовать зарезервированное ключевое слово this.Во время исполнения функции, в this записывается ссылка на объект,
// в контексте которого она была вызвана.
// Таким образом, в теле функции мы можем получить доступ к свойствам и методам этого объекта.

// Петя бежит быстро, потому что он (this) пытается поймать поезд.
const petya2 = {
  username: 'Petya',
  showName() {
    console.log(this.username);
  },
};

petya2.showName();

// Разберем пример с коллекцией книг.

const bookShelf = {
  authors: ['Бернард Корнуэлл', 'Роберт Шекли'],
  getAuthors() {
    return this.authors;
  },
  addAuthor(authorName) {
    this.authors.push(authorName);
  },
};

console.log(bookShelf.getAuthors()); // ["Бернард Корнуэлл", "Роберт Шекли"]
bookShelf.addAuthor('Ли Танит');
console.log(bookShelf.getAuthors()); // ["Бернард Корнуэлл", "Роберт Шекли", "Ли Танит"]

// Методы getAuthors и addAuthor это функции(методы объекта), которые вызываются в контексте объекта bookShelf.
// Во время их выполнения в this записывается ссылка на объект bookShelf и мы можем обратиться к его свойствам и методам.

//? ------------ Правила определения this ------------

// Необходимо усвоить всего одно правило для определения this - значение контекста внутри функции(не стрелочной) определятся не в момент ее создания,
// а в момент вызова.То есть значение this определяется тем, как вызывается функция, а не где она была объявлена.

// this в глобальной области видимости
// В глобальной области видимости, если скрипт выполняется не в строгом режиме, this ссылается на объект window.
// В строгом режиме значение this, в глобальной области видимости, будет undefined.

function foo() {
  console.log(this);
}

foo(); // window без "use strict" и undefined с "use strict"

//? --------------- this в методе объекта ---------------

// Если функция была вызвана как метод объекта, то контекст будет ссылаться на объект, частью которого является метод.

const petya = {
  username: 'Petya',
  showThis() {
    console.log(this);
  },
  showName() {
    console.log(this.username);
  },
};

petya.showThis(); // {username: "Petya", showThis: ƒ, showName: ƒ}
petya.showName(); // 'Petya'

// Разберем более сложный пример для лучшего понимания.

// Сначала создадим функцию в глобальной области видимости и вызовем ее.
// После чего присвоим ее в свойство объекта и вызовем как метод этого объекта.

function showThis() {
  console.log('this in showThis: ', this);
}

// Вызываем в глобальном контексте
showThis(); // this in showThis: Window

const user = {
  username: 'Mango',
};

// Записываем ссылку на функцию в свойство объекта
// Обратите внимание, что это не вызов - нет ()
user.showContext = showThis;

// Вызываем функцию в контексте объекта
// this будет указывать на текущий объект, в контексте
// которого осуществляется вызов, а не на глобальный объект.
user.showContext(); // this in showThis: {username: "Mango", showContext: ƒ}

//? ----------------- this в callback-функциях ------------------

// При передаче методов объекта как колбэк - функций, контекст не сохраняется.Колбэк это ссылка на метод,
// которая присваивается как значение параметра, вызываемого без объекта.

const customer = {
  firstName: 'Jacob',
  lastName: 'Mercer',
  getFullName() {
    return `${this.firstName} ${this.lastName}`;
  },
};

function makeMessage(callback) {
  // callback() это вызов метода getFullName без объекта
  console.log(`Обрабатываем заявку от ${callback()}.`);
}

makeMessage(customer.getFullName); // Будет ошибка при вызове функции
/*
ИНТЕРЕСНО
Решение этой проблемы рассматривается в секции про метод bind() и методы объекта.
*/

//? ---------------- this в стрелочных функциях --------------

// Стрелочные функции не имеют своего this. В отличии от обычных функций, изменить значение this внутри стрелки после её объявления нельзя.
/*
ИНТЕРЕСНО
Контекст внутри стрелки определяется местом её объявления, а не вызова и ссылается на контекст родительской функции.
*/
// Стрелочные функции также игнорируют наличие строгого режима.Если стрелка запомнила глобальный контекст,
// то this в ней будет содержать ссылку на window независимо от того, выполняется скрипт в строгом режиме или нет.

const showThis = () => {
  console.log('this in showThis: ', this);
};

showThis(); // this in showThis: window

const user = {
  username: 'Mango',
};
user.showContext = showThis;

user.showContext(); // this in showThis: window

// Ограничивая стрелочные функции постоянным контекстом, JavaScript - движки могут лучше их оптимизировать,
// в отличие от обычных функций, значение this которых может быть изменено.

// Пример не практичный, но отлично показывает как работает контекст для стрелок.
// Значение контекста берется из родительской области видимости.

const hotel = {
  username: 'Resort hotel',
  showThis() {
    const foo = () => {
      // Стрелки запоминают контекст во время объявления,
      // из родительской области видимости
      console.log('this in foo: ', this);
    };

    foo();
    console.log('this in showThis: ', this);
  },
};

hotel.showThis();
// this in foo: {username: 'Resort hotel', showThis: ƒ}
// this in showThis: {username: 'Resort hotel',showThis: ƒ}
