//?-------------------------------------------------------

/*
Enough is enough!

Алиса и Боб были в отпуске. Они оба сделали много фотографий мест, 
где побывали, и теперь хотят показать Чарли всю свою коллекцию. 
Однако эти сеансы не нравятся Чарли, так как мотив обычно повторяется. 
Ему не нравится смотреть на Эйфелеву башню 40 раз.
Он говорит им, что будет сидеть на сеансе только в том случае, 
если они будут показывать один и тот же мотив в большинстве N случаев. 
К счастью, Алиса и Боб могут закодировать мотив как число. 
Можете ли вы помочь им удалить числа так, чтобы их список содержал 
каждое число только до N раз, не меняя порядок?

Задача
Учитывая список и число, создайте новый список, который содержит 
каждое число list не более N раз, без изменения порядка.
Например, если входной номер равен 2, а входной список — [1,2,3,1,2,1,2,3],
вы берете [1,2,3,1,2], отбрасываете следующий, [1,2] поскольку это приведет 
к 1 и 2 будет в результате 3 раз, а затем берете 3, что приводит к [1,2,3,1,2,3].
Со списком [20,37,20,21] и числом 1 результатом будет [20,37,21].
*/
function deleteNth(arr, n) {
  // ...
}

// console.log(deleteNth([20, 37, 20, 21], 1)); // [20,37,21]
// console.log(deleteNth([1, 1, 3, 3, 7, 2, 2, 2, 2], 3)); // [1, 1, 3, 3, 7, 2, 2, 2]

//? ------------------------------------------------
/*
Sum of the first nth term of Series

Ваша задача — написать функцию, которая возвращает сумму следующих рядов 
до n-го члена (параметра).

Series: 1 + 1/4 + 1/7 + 1/10 + 1/13 + 1/16 +...
Правила:
Вам нужно округлить ответ до 2 знаков после запятой и вернуть его как строку.

Если заданное значение равно 0, оно должно вернуть 0,00.

В качестве аргументов вам будут предоставлены только натуральные числа.

Примеры: (Ввод --> Вывод)
1 --> 1 --> "1.00"
2 --> 1 + 1/4 --> "1.25"
5 --> 1 + 1/4 + 1/7 + 1/10 + 1/13 --> "1.57"
*/
function SeriesSum(n) {
  // Happy Coding ^_^
}

// console.log(SeriesSum(1)); // "1.00"
// console.log(SeriesSum(2)); // "1.25"
// console.log(SeriesSum(3)); // "1.39"
// console.log(SeriesSum(4)); // "1.49"

//? ------------------------------------------------
/*
Simple Encryption #1 - Alternating Split

Реализуйте алгоритм псевдошифрования, который для заданной строки 
S и целого числа N объединяет все символы с нечетным индексом S со всеми 
символами с четным индексом S, этот процесс следует повторять несколько N раз.

Примеры:

encrypt("012345", 1)  =>  "135024"
encrypt("012345", 2)  =>  "135024"  ->  "304152"
encrypt("012345", 3)  =>  "135024"  ->  "304152"  ->  "012345"

encrypt("01234", 1)  =>  "13024"
encrypt("01234", 2)  =>  "13024"  ->  "32104"
encrypt("01234", 3)  =>  "13024"  ->  "32104"  ->  "20314"
Вместе с функцией шифрования вы также должны реализовать функцию дешифрования, 
которая меняет процесс.

Если строка S является пустым значением или целое число N не является 
положительным, вернуть первый аргумент без изменений.
*/
function encrypt(text, n) {}

function decrypt(encryptedText, n) {}

// console.log(encrypt('This is a test!', 0)); // "This is a test!"
// console.log(encrypt('This is a test!', 1)); // "hsi  etTi sats!"
// console.log(encrypt('This is a test!', 2)); // "s eT ashi tist!"
// console.log(encrypt("This kata is very interesting!", 1)); // "hskt svr neetn!Ti aai eyitrsig"

// console.log(decrypt(' Tah itse sits!', 3)); // "This is a test!"
// console.log(decrypt("This is a test!", 4)); // "This is a test!"
// console.log(decrypt('This is a test!', -1)); // "This is a test!"
// console.log(decrypt('hskt svr neetn!Ti aai eyitrsig', 1)); // "This kata is very interesting!"

//? ------------------------------------------------
/*
Replace With Alphabet Position

В этой ката вы должны, учитывая строку, заменить каждую букву 
ее позицией в алфавите.

Если что-то в тексте не является буквой, игнорируйте это и не возвращайте.

"a" = 1, "b" = 2, и т.д.

Пример
alphabetPosition("The sunset sets at twelve o' clock.")
Должен возвращаться "20 8 5 19 21 14 19 5 20 19 5 20 19 1 20 20 23 5 12 22 5 15 3 12 15 3 11"(в виде строки)
*/
function alphabetPosition(text) {
  return text;
}

// console.log(alphabetPosition("The sunset sets at twelve o' clock.")); // "20 8 5 19 21 14 19 5 20 19 5 20 19 1 20 20 23 5 12 22 5 15 3 12 15 3 11"
// console.log(alphabetPosition('The narwhal bacons at midnight.')); // "20 8 5 14 1 18 23 8 1 12 2 1 3 15 14 19 1 20 13 9 4 14 9 7 8 20"
//? ------------------------------------------------
/*
Playing with digits

Некоторые числа обладают забавными свойствами. Например:

89 --> 8¹ + 9² = 89 * 1

695 --> 6² + 9³ + 5⁴= 1390 = 695 * 2

46288 --> 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51

Даны положительное целое число n, записанное в виде abcd... 
(a, b, c, d... являются цифрами), и положительное целое число p

мы хотим найти положительное целое число k, если оно существует, 
такое, что сумма цифр n, взятых в последовательных степенях p, равна k * n.
Другими словами:

Существует ли целое число k, такое как: (a ^ p + b ^ (p+1) + c ^ (p+2) + d ^ (p+3) + ...) = n * k

Если это так, мы вернем k, если нет, вернем -1.

Примечание : n и p всегда задаются как строго положительные целые числа.

digPow(89, 1) should return 1 since 8¹ + 9² = 89 = 89 * 1
digPow(92, 1) should return -1 since there is no k such as 9¹ + 2² equals 92 * k
digPow(695, 2) should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2
digPow(46288, 3) should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51
*/
function digPow(n, p) {
  // ...
}

// console.log(digPow(89, 1)); // 1
// console.log(digPow(92, 1)); // -1
// console.log(digPow(46288, 3)); // 51
//? ------------------------------------------------
