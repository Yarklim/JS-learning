//?-------------------------------------------------------
/*
Growth of a Population

В маленьком городке население p0 = 1000 на начало года. 
Население регулярно увеличивается на 2 percent 1 год, и, кроме того , 
50 каждый год в город приезжают новые жители. Сколько лет нужно городу, 
чтобы его население было больше или равно количеству p = 1200 жителей?

At the end of the first year there will be: 
1000 + 1000 * 0.02 + 50 => 1070 inhabitants

At the end of the 2nd year there will be: 
1070 + 1070 * 0.02 + 50 => 1141 inhabitants (** number of inhabitants is an integer **)

At the end of the 3rd year there will be:
1141 + 1141 * 0.02 + 50 => 1213

It will need 3 entire years.
Более общие параметры:

p0, percent, aug (inhabitants coming or leaving each year), 
p (population to equal or surpass)

функция nb_year должна возвращать n количество полных лет, 
необходимых для получения населения, большего или равного p.

aug — целое число, процент — положительное или нулевое плавающее число, 
p0 и p — положительные целые числа (> 0)

Examples:
nb_year(1500, 5, 100, 5000) -> 15
nb_year(1500000, 2.5, 10000, 2000000) -> 10
Примечание:
Не забудьте преобразовать параметр процента в процент в теле 
вашей функции: если параметр процента равен 2, 
вы должны преобразовать его в 0,02.
*/
function nbYear(p0, percent, aug, p) {
  // your code
}

// console.log(nbYear(1500, 5, 100, 5000)); // 15
// console.log(nbYear(1500000, 2.5, 10000, 2000000)); // 10
// console.log(nbYear(1500000, 0.25, 1000, 2000000)); // 94
//?-------------------------------------------------------

/*
Persistent Bugger.

Напишите функцию , persistence которая принимает положительный параметр 
num и возвращает его мультипликативную постоянство, 
то есть количество раз, которое вы должны умножить на цифры num, 
пока не получите одну цифру.

Например (Ввод --> Вывод) :

39 --> 3 (because 3*9 = 27, 2*7 = 14, 1*4 = 4 and 4 has only one digit)
999 --> 4 (because 9*9*9 = 729, 7*2*9 = 126, 1*2*6 = 12, and finally 1*2 = 2)
4 --> 0 (because 4 is already a one-digit number)
*/
function persistence(num) {
  let sum = 0;
  let counter = 0;
  const arrStr = num.toString().split('');

  if (arrStr.length === 1) return 0;

  const newSum = arrStr.reduce((total, item) => total * item, 1);

  return newSum;
}

console.log(persistence(39)); // 3
console.log(persistence(4)); // 0
console.log(persistence(25)); // 2
console.log(persistence(999)); // 4
//? -----------------------------------------------

/*
Money, Money, Money

У мистера Скруджа есть сумма денег «P», которую он хочет инвестировать. 
Прежде чем он это сделает, он хочет знать, сколько лет «Y» 
эта сумма «P» должна храниться в банке, чтобы она составила 
желаемую сумму денег «D».

Сумма хранится в течение Y лет в банке, где проценты I выплачиваются 
ежегодно. После уплаты налогов «Т» за год новая сумма реинвестируется.

Примечание к налогам: налогом облагается не инвестированная основная 
сумма, а только начисленные проценты за год.

Пример:

  Let P be the Principal = 1000.00      
  Let I be the Interest Rate = 0.05      
  Let T be the Tax Rate = 0.18      
  Let D be the Desired Sum = 1100.00


After 1st Year -->
  P = 1041.00
After 2nd Year -->
  P = 1083.86
After 3rd Year -->
  P = 1128.30
Таким образом, г-н Скрудж должен ждать 3 года, чтобы первоначальный 
основной капитал составил желаемую сумму.

Ваша задача — завершить предоставленный метод и вернуть количество лет
 «Y» в целом, чтобы мистер Скрудж получил желаемую сумму.

Предположение: предположим, что желаемый принципал «D» всегда больше, 
чем первоначальный принципал. Однако лучше принять во внимание, 
что если желаемый основной «D» равен основному «P», 
это должно вернуть 0 лет.
*/
function calculateYears(principal, interest, tax, desired) {
  // your code
}

// console.log(calculateYears(1000, 0.05, 0.18, 1100)); // 3
// console.log(calculateYears(1000, 0.01625, 0.18, 1200)); // 14
// console.log(calculateYears(1000, 0.05, 0.18, 1000)); // 0
//? ------------------------------------------------
/*
Enough is enough!

Алиса и Боб были в отпуске. Они оба сделали много фотографий мест, 
где побывали, и теперь хотят показать Чарли всю свою коллекцию. 
Однако эти сеансы не нравятся Чарли, так как мотив обычно повторяется. 
Ему не нравится смотреть на Эйфелеву башню 40 раз.
Он говорит им, что будет сидеть на сеансе только в том случае, 
если они будут показывать один и тот же мотив в большинстве N случаев. 
К счастью, Алиса и Боб могут закодировать мотив как число. 
Можете ли вы помочь им удалить числа так, чтобы их список содержал 
каждое число только до Nраз, не меняя порядок?

Задача
Учитывая список и число, создайте новый список, который содержит 
каждое число listне более N раз, без изменения порядка.
Например, если входной номер равен 2, а входной список — [1,2,3,1,2,1,2,3],
вы берете [1,2,3,1,2], отбрасываете следующий, [1,2] поскольку это приведет 
к 1 и 2 будет в результате 3 раз, а затем берете 3, что приводит к [1,2,3,1,2,3].
Со списком [20,37,20,21] и числом 1 результатом будет [20,37,21].
*/
function deleteNth(arr, n) {
  // ...
}

// console.log(deleteNth([20, 37, 20, 21], 1)); // [20,37,21]
// console.log(deleteNth([1, 1, 3, 3, 7, 2, 2, 2, 2], 3)); // [1, 1, 3, 3, 7, 2, 2, 2]

//? ------------------------------------------------
/*
Sum of the first nth term of Series

Ваша задача — написать функцию, которая возвращает сумму следующих рядов 
до n-го члена (параметра).

Series: 1 + 1/4 + 1/7 + 1/10 + 1/13 + 1/16 +...
Правила:
Вам нужно округлить ответ до 2 знаков после запятой и вернуть его как строку.

Если заданное значение равно 0, оно должно вернуть 0,00.

В качестве аргументов вам будут предоставлены только натуральные числа.

Примеры: (Ввод --> Вывод)
1 --> 1 --> "1.00"
2 --> 1 + 1/4 --> "1.25"
5 --> 1 + 1/4 + 1/7 + 1/10 + 1/13 --> "1.57"
*/
function SeriesSum(n) {
  // Happy Coding ^_^
}

// console.log(SeriesSum(1)); // "1.00"
// console.log(SeriesSum(2)); // "1.25"
// console.log(SeriesSum(3)); // "1.39"
// console.log(SeriesSum(4)); // "1.49"

//? ------------------------------------------------
/*
Simple Encryption #1 - Alternating Split

Реализуйте алгоритм псевдошифрования, который для заданной строки 
S и целого числа N объединяет все символы с нечетным индексом S со всеми 
символами с четным индексом S, этот процесс следует повторять несколько N раз.

Примеры:

encrypt("012345", 1)  =>  "135024"
encrypt("012345", 2)  =>  "135024"  ->  "304152"
encrypt("012345", 3)  =>  "135024"  ->  "304152"  ->  "012345"

encrypt("01234", 1)  =>  "13024"
encrypt("01234", 2)  =>  "13024"  ->  "32104"
encrypt("01234", 3)  =>  "13024"  ->  "32104"  ->  "20314"
Вместе с функцией шифрования вы также должны реализовать функцию дешифрования, 
которая меняет процесс.

Если строка S является пустым значением или целое число N не является 
положительным, вернуть первый аргумент без изменений.
*/
function encrypt(text, n) {}

function decrypt(encryptedText, n) {}

// console.log(encrypt('This is a test!', 0)); // "This is a test!"
// console.log(encrypt('This is a test!', 1)); // "hsi  etTi sats!"
// console.log(encrypt('This is a test!', 2)); // "s eT ashi tist!"
// console.log(encrypt("This kata is very interesting!", 1)); // "hskt svr neetn!Ti aai eyitrsig"

// console.log(decrypt(' Tah itse sits!', 3)); // "This is a test!"
// console.log(decrypt("This is a test!", 4)); // "This is a test!"
// console.log(decrypt('This is a test!', -1)); // "This is a test!"
// console.log(decrypt('hskt svr neetn!Ti aai eyitrsig', 1)); // "This kata is very interesting!"

//? ------------------------------------------------
/*
Replace With Alphabet Position

В этой ката вы должны, учитывая строку, заменить каждую букву 
ее позицией в алфавите.

Если что-то в тексте не является буквой, игнорируйте это и не возвращайте.

"a" = 1, "b" = 2, и т.д.

Пример
alphabetPosition("The sunset sets at twelve o' clock.")
Должен возвращаться "20 8 5 19 21 14 19 5 20 19 5 20 19 1 20 20 23 5 12 22 5 15 3 12 15 3 11"(в виде строки)
*/
function alphabetPosition(text) {
  return text;
}

// console.log(alphabetPosition("The sunset sets at twelve o' clock.")); // "20 8 5 19 21 14 19 5 20 19 5 20 19 1 20 20 23 5 12 22 5 15 3 12 15 3 11"
// console.log(alphabetPosition('The narwhal bacons at midnight.')); // "20 8 5 14 1 18 23 8 1 12 2 1 3 15 14 19 1 20 13 9 4 14 9 7 8 20"
//? ------------------------------------------------
/*
Playing with digits

Некоторые числа обладают забавными свойствами. Например:

89 --> 8¹ + 9² = 89 * 1

695 --> 6² + 9³ + 5⁴= 1390 = 695 * 2

46288 --> 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51

Даны положительное целое число n, записанное в виде abcd... 
(a, b, c, d... являются цифрами), и положительное целое число p

мы хотим найти положительное целое число k, если оно существует, 
такое, что сумма цифр n, взятых в последовательных степенях p, равна k * n.
Другими словами:

Существует ли целое число k, такое как: (a ^ p + b ^ (p+1) + c ^ (p+2) + d ^ (p+3) + ...) = n * k

Если это так, мы вернем k, если нет, вернем -1.

Примечание : n и p всегда задаются как строго положительные целые числа.

digPow(89, 1) should return 1 since 8¹ + 9² = 89 = 89 * 1
digPow(92, 1) should return -1 since there is no k such as 9¹ + 2² equals 92 * k
digPow(695, 2) should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2
digPow(46288, 3) should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51
*/
function digPow(n, p) {
  // ...
}

// console.log(digPow(89, 1)); // 1
// console.log(digPow(92, 1)); // -1
// console.log(digPow(46288, 3)); // 51
//? ------------------------------------------------
