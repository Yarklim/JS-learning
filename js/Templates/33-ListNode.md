Что такое связанный список?

Связный список — это линейная структура данных, похожая на массив. Однако, в отличие от массивов, элементы не хранятся в определенной ячейке памяти или индексе. Скорее каждый элемент представляет собой отдельный объект, который содержит указатель или ссылку на следующий объект в этом списке.

Каждый элемент (обычно называемый узлами) содержит два элемента: сохраненные данные и ссылку на следующий узел. Данные могут быть любого допустимого типа данных. Вы можете увидеть это на диаграмме ниже.

  Head
  [6] -> [10] -> [12] -> [3] -> null


Точка входа в связанный список называется головой. Голова — это ссылка на первый узел в связанном списке. Последний узел в списке указывает на ноль. Если список пуст, заголовок является нулевой ссылкой.

В JavaScript связанный список выглядит так:

const list = {
    head: {
        value: 6
        next: {
            value: 10                                             
            next: {
                value: 12
                next: {
                    value: 3
                    next: null	
                    }
                }
            }
        }
    }
};
Как видите, список — это объект, содержащий несколько слоев данных. Каждый слой в списке имеет свойство valueи . nextСвойство nextсодержит связанный список (объект со свойствами valи ).next

Если вы напечатаете первый элемент:

console.log(list.val)  // 6
console.log(list.next) // {val: 10, next: { val: 12, next: {...} }}


Формальное определение узла:

function ListNode(val, next) {
    this.val  = val  === undefined ? 0    : val
    this.next = next === undefined ? null : next
}


Вы можете создать предыдущий объект, определяющий каждый узел:

// This is equivalent to: let list = {val: 6, next: {...} }
let list = new ListNode(6, new ListNode(10, new ListNode(12, new ListNode(3))))


Когда использовать эту структуру?

Возможно, вам интересно, зачем использовать эту структуру, если вы можете использовать массив, а не связанный список:

let list = [3, 4, 2, 7]
Они полезны, если вы хотите добавить или удалить данные. Например, в предыдущем массиве предположим, что вы хотели добавить 9 в index = 1.

let list  = [3, 4, 2, 7]
let index = 1

for(let i = list.length; i >= index; i --){
    list[i] = list[i - 1]
}

list[index] = 9

console.log(list) 
// [3, 9, 4, 2, 7]


Принимая во внимание, что если вы используете связанный список:

let list = {
    val: 3,
    next: {
        val: 4,
        next: {
            val: 2,
            next: {
                val: 7,
                next: null
            }
        }
    }
}

let _list = list.next

list.next.val  = 9
list.next.next = _list

console.log(list)
// {val: 3, next: {val: 9, next: {... }}}
В первом примере вы записываете 4 новых значения. В последнем примере вы записываете только 1 новое значение при перенаправлении указателей. Вот почему изменение массива имеет временную сложность O(n), тогда как изменение связанного списка имеет временную сложность O(1).

Преимущество связанных списков
Узлы можно легко удалять или добавлять из связанного списка без реорганизации всей структуры данных. Это одно из его преимуществ перед массивами.
Недостатки связанных списков
Операции поиска в связанных списках выполняются медленно. В отличие от массивов, произвольный доступ к элементам данных не допускается. Доступ к узлам осуществляется последовательно, начиная с первого узла.
Он использует больше памяти, чем массивы, из-за хранения указателей.
Типы связанных списков
Существует три типа связанных списков:

Односвязные списки : каждый узел содержит только один указатель на следующий узел. Это то, о чем мы говорили до сих пор.
Двусвязные списки : каждый узел содержит два указателя, указатель на следующий узел и указатель на предыдущий узел.
Циклические связанные списки . Циклические связанные списки — это вариант связанного списка, в котором последний узел указывает на первый узел или любой другой узел перед ним, тем самым образуя петлю.
Реализация узла списка в JavaScript
Как было сказано ранее, узел списка содержит два элемента: данные и указатель на следующий узел. Мы можем реализовать узел списка в JavaScript следующим образом:

class ListNode {
    constructor(data) {
        this.data = data
        this.next = null                
    }
}
Реализация связанного списка в JavaScript
В приведенном ниже коде показана реализация класса связанного списка с конструктором. Обратите внимание, что если головной узел не передается, он инициализируется нулем.

class LinkedList {
    constructor(head = null) {
        this.head = head
    }
}
Собираем все вместе
Давайте создадим связанный список с классом, который мы только что создали. Сначала мы создаем два узла списка node1и node2указатель с узла 1 на узел 2.

let node1 = new ListNode(2)
let node2 = new ListNode(5)
node1.next = node2
Далее мы создадим связанный список с расширением node1.

let list = new LinkedList(node1)
Давайте попробуем получить доступ к узлам в списке, который мы только что создали.

console.log(list.head.next.data) //returns 5
Некоторые методы LinkedList
Далее мы реализуем четыре вспомогательных метода для связанного списка. Они есть:

размер()
Чисто()
получитьпоследнее()
получитьпервый()
1. размер()
Этот метод возвращает количество узлов, присутствующих в связанном списке.

size() {
    let count = 0; 
    let node = this.head;
    while (node) {
        count++;
        node = node.next
    }
    return count;
}
2. очистить()
Этот метод очищает список.

clear() {
    this.head = null;
}
3. получить последний()
Этот метод возвращает последний узел связанного списка.

getLast() {
    let lastNode = this.head;
    if (lastNode) {
        while (lastNode.next) {
            lastNode = lastNode.next
        }
    }
    return lastNode
}
4. ПолучитьПервый()
Этот метод возвращает первый узел связанного списка.

getFirst() {
    return this.head;
}

# ================== Пример =======================
var addTwoNumbers = function (l1, l2) {
	let carry = 0;
	let result = new ListNode(-1);
	let final = result;

	while (l1 || l2 || carry) {
		let l1Val = l1 ? l1.val : 0;
		let l2Val = l2 ? l2.val : 0;

		let nextDigit = (l1Val + l2Val + carry) % 10;
		result.next = new ListNode(nextDigit);
		result = result.next;

		carry = Math.floor((l1Val + l2Val + carry) / 10);

		l1 = l1 ? l1.next : null;
		l2 = l2 ? l2.next : null;
	}

	return final.next;
};
// console.log(addTwoNumbers([2, 4, 3], [5, 6, 4]));